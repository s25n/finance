{
  "language": "Solidity",
  "sources": {
    "contracts/space/Math64x64.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\n/*\r\n *  Math 64.64 Smart Contract Library.  Copyright Â© 2019 by  Consulting.\r\n * Author: Mikhail Vladimirov <mikhail.vladimirov@gmail.com>\r\n */\r\npragma solidity 0.8.6;\r\n\r\n/**\r\n * Smart contract library of mathematical functions operating with signed\r\n * 64.64-bit fixed point numbers.  Signed 64.64-bit fixed point number is\r\n * basically a simple fraction whose numerator is signed 128-bit integer and\r\n * denominator is 2^64.  As long as denominator is always the same, there is no\r\n * need to store it, thus in Solidity signed 64.64-bit fixed point numbers are\r\n * represented by int128 type holding only the numerator.\r\n */\r\nlibrary Math64x64 {\r\n    /*\r\n     * Minimum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MIN_64x64 = -0x80000000000000000000000000000000;\r\n\r\n    /*\r\n     * Maximum value signed 64.64-bit fixed point number may have.\r\n     */\r\n    int128 private constant MAX_64x64 = 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF;\r\n\r\n    /**\r\n     * Convert signed 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromInt(int256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x >= -0x8000000000000000 && x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(x << 64);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 64-bit integer number\r\n     * rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64-bit integer number\r\n     */\r\n    function toInt(int128 x) internal pure returns (int64) {\r\n        unchecked {\r\n            return int64(x >> 64);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert unsigned 256-bit integer number into signed 64.64-bit fixed point\r\n     * number.  Revert on overflow.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function fromUInt(uint256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x <= 0x7FFFFFFFFFFFFFFF);\r\n            return int128(int256(x << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into unsigned 64-bit integer\r\n     * number rounding down.  Revert on underflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return unsigned 64-bit integer number\r\n     */\r\n    function toUInt(int128 x) internal pure returns (uint64) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return uint64(uint128(x >> 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 128.128 fixed point number into signed 64.64-bit fixed point\r\n     * number rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 128.128-bin fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function from128x128(int256 x) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = x >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Convert signed 64.64 fixed point number into signed 128.128 fixed point\r\n     * number.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 128.128 fixed point number\r\n     */\r\n    function to128x128(int128 x) internal pure returns (int256) {\r\n        unchecked {\r\n            return int256(x) << 64;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x + y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function add(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) + y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x - y.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function sub(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = int256(x) - y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function mul(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 result = (int256(x) * y) >> 64;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding towards zero, where x is signed 64.64 fixed point\r\n     * number and y is signed 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n     * @param y signed 256-bit integer number\r\n     * @return signed 256-bit integer number\r\n     */\r\n    function muli(int128 x, int256 y) internal pure returns (int256) {\r\n        unchecked {\r\n            if (x == MIN_64x64) {\r\n                require(\r\n                    y >= -0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF &&\r\n                        y <= 0x1000000000000000000000000000000000000000000000000\r\n                );\r\n                return -y << 63;\r\n            } else {\r\n                bool negativeResult = false;\r\n                if (x < 0) {\r\n                    x = -x;\r\n                    negativeResult = true;\r\n                }\r\n                if (y < 0) {\r\n                    y = -y; // We rely on overflow behavior here\r\n                    negativeResult = !negativeResult;\r\n                }\r\n                uint256 absoluteResult = mulu(x, uint256(y));\r\n                if (negativeResult) {\r\n                    require(\r\n                        absoluteResult <=\r\n                            0x8000000000000000000000000000000000000000000000000000000000000000\r\n                    );\r\n                    return -int256(absoluteResult); // We rely on overflow behavior here\r\n                } else {\r\n                    require(\r\n                        absoluteResult <=\r\n                            0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\r\n                    );\r\n                    return int256(absoluteResult);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x * y rounding down, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64 fixed point number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return unsigned 256-bit integer number\r\n     */\r\n    function mulu(int128 x, uint256 y) internal pure returns (uint256) {\r\n        unchecked {\r\n            if (y == 0) return 0;\r\n\r\n            require(x >= 0);\r\n\r\n            uint256 lo = (uint256(int256(x)) *\r\n                (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)) >> 64;\r\n            uint256 hi = uint256(int256(x)) * (y >> 128);\r\n\r\n            require(hi <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            hi <<= 64;\r\n\r\n            require(\r\n                hi <=\r\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF -\r\n                        lo\r\n            );\r\n            return hi + lo;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero.  Revert on overflow or when y is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function div(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n            int256 result = (int256(x) << 64) / y;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are signed 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x signed 256-bit integer number\r\n     * @param y signed 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function divi(int256 x, int256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n\r\n            bool negativeResult = false;\r\n            if (x < 0) {\r\n                x = -x; // We rely on overflow behavior here\r\n                negativeResult = true;\r\n            }\r\n            if (y < 0) {\r\n                y = -y; // We rely on overflow behavior here\r\n                negativeResult = !negativeResult;\r\n            }\r\n            uint128 absoluteResult = divuu(uint256(x), uint256(y));\r\n            if (negativeResult) {\r\n                require(absoluteResult <= 0x80000000000000000000000000000000);\r\n                return -int128(absoluteResult); // We rely on overflow behavior here\r\n            } else {\r\n                require(absoluteResult <= 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n                return int128(absoluteResult); // We rely on overflow behavior here\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function divu(uint256 x, uint256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            require(y != 0);\r\n            uint128 result = divuu(x, y);\r\n            require(result <= uint128(MAX_64x64));\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate -x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function neg(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != MIN_64x64);\r\n            return -x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate |x|.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function abs(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != MIN_64x64);\r\n            return x < 0 ? -x : x;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate 1 / x rounding towards zero.  Revert on overflow or when x is\r\n     * zero.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function inv(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x != 0);\r\n            int256 result = int256(0x100000000000000000000000000000000) / x;\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate arithmetics average of x and y, i.e. (x + y) / 2 rounding down.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function avg(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            return int128((int256(x) + int256(y)) >> 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate geometric average of x and y, i.e. sqrt (x * y) rounding down.\r\n     * Revert on overflow or in case x * y is negative.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function gavg(int128 x, int128 y) internal pure returns (int128) {\r\n        unchecked {\r\n            int256 m = int256(x) * int256(y);\r\n            require(m >= 0);\r\n            require(\r\n                m <\r\n                    0x4000000000000000000000000000000000000000000000000000000000000000\r\n            );\r\n            return int128(sqrtu(uint256(m)));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x^y assuming 0^0 is 1, where x is signed 64.64 fixed point number\r\n     * and y is unsigned 256-bit integer number.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @param y uint256 value\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function pow(int128 x, uint256 y) internal pure returns (int128) {\r\n        unchecked {\r\n            bool negative = x < 0 && y & 1 == 1;\r\n\r\n            uint256 absX = uint128(x < 0 ? -x : x);\r\n            uint256 absResult;\r\n            absResult = 0x100000000000000000000000000000000;\r\n\r\n            if (absX <= 0x10000000000000000) {\r\n                absX <<= 63;\r\n                while (y != 0) {\r\n                    if (y & 0x1 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x2 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x4 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    if (y & 0x8 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n\r\n                    y >>= 4;\r\n                }\r\n\r\n                absResult >>= 64;\r\n            } else {\r\n                uint256 absXShift = 63;\r\n                if (absX < 0x1000000000000000000000000) {\r\n                    absX <<= 32;\r\n                    absXShift -= 32;\r\n                }\r\n                if (absX < 0x10000000000000000000000000000) {\r\n                    absX <<= 16;\r\n                    absXShift -= 16;\r\n                }\r\n                if (absX < 0x1000000000000000000000000000000) {\r\n                    absX <<= 8;\r\n                    absXShift -= 8;\r\n                }\r\n                if (absX < 0x10000000000000000000000000000000) {\r\n                    absX <<= 4;\r\n                    absXShift -= 4;\r\n                }\r\n                if (absX < 0x40000000000000000000000000000000) {\r\n                    absX <<= 2;\r\n                    absXShift -= 2;\r\n                }\r\n                if (absX < 0x80000000000000000000000000000000) {\r\n                    absX <<= 1;\r\n                    absXShift -= 1;\r\n                }\r\n\r\n                uint256 resultShift = 0;\r\n                while (y != 0) {\r\n                    require(absXShift < 64);\r\n\r\n                    if (y & 0x1 != 0) {\r\n                        absResult = (absResult * absX) >> 127;\r\n                        resultShift += absXShift;\r\n                        if (absResult > 0x100000000000000000000000000000000) {\r\n                            absResult >>= 1;\r\n                            resultShift += 1;\r\n                        }\r\n                    }\r\n                    absX = (absX * absX) >> 127;\r\n                    absXShift <<= 1;\r\n                    if (absX >= 0x100000000000000000000000000000000) {\r\n                        absX >>= 1;\r\n                        absXShift += 1;\r\n                    }\r\n\r\n                    y >>= 1;\r\n                }\r\n\r\n                require(resultShift < 64);\r\n                absResult >>= 64 - resultShift;\r\n            }\r\n            int256 result = negative ? -int256(absResult) : int256(absResult);\r\n            require(result >= MIN_64x64 && result <= MAX_64x64);\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down.  Revert if x < 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function sqrt(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x >= 0);\r\n            return int128(sqrtu(uint256(int256(x)) << 64));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function log_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            int256 msb = 0;\r\n            int256 xc = x;\r\n            if (xc >= 0x10000000000000000) {\r\n                xc >>= 64;\r\n                msb += 64;\r\n            }\r\n            if (xc >= 0x100000000) {\r\n                xc >>= 32;\r\n                msb += 32;\r\n            }\r\n            if (xc >= 0x10000) {\r\n                xc >>= 16;\r\n                msb += 16;\r\n            }\r\n            if (xc >= 0x100) {\r\n                xc >>= 8;\r\n                msb += 8;\r\n            }\r\n            if (xc >= 0x10) {\r\n                xc >>= 4;\r\n                msb += 4;\r\n            }\r\n            if (xc >= 0x4) {\r\n                xc >>= 2;\r\n                msb += 2;\r\n            }\r\n            if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n            int256 result = (msb - 64) << 64;\r\n            uint256 ux = uint256(int256(x)) << uint256(127 - msb);\r\n            for (int256 bit = 0x8000000000000000; bit > 0; bit >>= 1) {\r\n                ux *= ux;\r\n                uint256 b = ux >> 255;\r\n                ux >>= 127 + b;\r\n                result += bit * int256(b);\r\n            }\r\n\r\n            return int128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural logarithm of x.  Revert if x <= 0.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function ln(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x > 0);\r\n\r\n            return\r\n                int128(\r\n                    int256(\r\n                        (uint256(int256(log_2(x))) *\r\n                            0xB17217F7D1CF79ABC9E3B39803F2F6AF) >> 128\r\n                    )\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate binary exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function exp_2(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x < 0x400000000000000000); // Overflow\r\n\r\n            if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n            uint256 result = 0x80000000000000000000000000000000;\r\n\r\n            if (x & 0x8000000000000000 > 0)\r\n                result = (result * 0x16A09E667F3BCC908B2FB1366EA957D3E) >> 128;\r\n            if (x & 0x4000000000000000 > 0)\r\n                result = (result * 0x1306FE0A31B7152DE8D5A46305C85EDEC) >> 128;\r\n            if (x & 0x2000000000000000 > 0)\r\n                result = (result * 0x1172B83C7D517ADCDF7C8C50EB14A791F) >> 128;\r\n            if (x & 0x1000000000000000 > 0)\r\n                result = (result * 0x10B5586CF9890F6298B92B71842A98363) >> 128;\r\n            if (x & 0x800000000000000 > 0)\r\n                result = (result * 0x1059B0D31585743AE7C548EB68CA417FD) >> 128;\r\n            if (x & 0x400000000000000 > 0)\r\n                result = (result * 0x102C9A3E778060EE6F7CACA4F7A29BDE8) >> 128;\r\n            if (x & 0x200000000000000 > 0)\r\n                result = (result * 0x10163DA9FB33356D84A66AE336DCDFA3F) >> 128;\r\n            if (x & 0x100000000000000 > 0)\r\n                result = (result * 0x100B1AFA5ABCBED6129AB13EC11DC9543) >> 128;\r\n            if (x & 0x80000000000000 > 0)\r\n                result = (result * 0x10058C86DA1C09EA1FF19D294CF2F679B) >> 128;\r\n            if (x & 0x40000000000000 > 0)\r\n                result = (result * 0x1002C605E2E8CEC506D21BFC89A23A00F) >> 128;\r\n            if (x & 0x20000000000000 > 0)\r\n                result = (result * 0x100162F3904051FA128BCA9C55C31E5DF) >> 128;\r\n            if (x & 0x10000000000000 > 0)\r\n                result = (result * 0x1000B175EFFDC76BA38E31671CA939725) >> 128;\r\n            if (x & 0x8000000000000 > 0)\r\n                result = (result * 0x100058BA01FB9F96D6CACD4B180917C3D) >> 128;\r\n            if (x & 0x4000000000000 > 0)\r\n                result = (result * 0x10002C5CC37DA9491D0985C348C68E7B3) >> 128;\r\n            if (x & 0x2000000000000 > 0)\r\n                result = (result * 0x1000162E525EE054754457D5995292026) >> 128;\r\n            if (x & 0x1000000000000 > 0)\r\n                result = (result * 0x10000B17255775C040618BF4A4ADE83FC) >> 128;\r\n            if (x & 0x800000000000 > 0)\r\n                result = (result * 0x1000058B91B5BC9AE2EED81E9B7D4CFAB) >> 128;\r\n            if (x & 0x400000000000 > 0)\r\n                result = (result * 0x100002C5C89D5EC6CA4D7C8ACC017B7C9) >> 128;\r\n            if (x & 0x200000000000 > 0)\r\n                result = (result * 0x10000162E43F4F831060E02D839A9D16D) >> 128;\r\n            if (x & 0x100000000000 > 0)\r\n                result = (result * 0x100000B1721BCFC99D9F890EA06911763) >> 128;\r\n            if (x & 0x80000000000 > 0)\r\n                result = (result * 0x10000058B90CF1E6D97F9CA14DBCC1628) >> 128;\r\n            if (x & 0x40000000000 > 0)\r\n                result = (result * 0x1000002C5C863B73F016468F6BAC5CA2B) >> 128;\r\n            if (x & 0x20000000000 > 0)\r\n                result = (result * 0x100000162E430E5A18F6119E3C02282A5) >> 128;\r\n            if (x & 0x10000000000 > 0)\r\n                result = (result * 0x1000000B1721835514B86E6D96EFD1BFE) >> 128;\r\n            if (x & 0x8000000000 > 0)\r\n                result = (result * 0x100000058B90C0B48C6BE5DF846C5B2EF) >> 128;\r\n            if (x & 0x4000000000 > 0)\r\n                result = (result * 0x10000002C5C8601CC6B9E94213C72737A) >> 128;\r\n            if (x & 0x2000000000 > 0)\r\n                result = (result * 0x1000000162E42FFF037DF38AA2B219F06) >> 128;\r\n            if (x & 0x1000000000 > 0)\r\n                result = (result * 0x10000000B17217FBA9C739AA5819F44F9) >> 128;\r\n            if (x & 0x800000000 > 0)\r\n                result = (result * 0x1000000058B90BFCDEE5ACD3C1CEDC823) >> 128;\r\n            if (x & 0x400000000 > 0)\r\n                result = (result * 0x100000002C5C85FE31F35A6A30DA1BE50) >> 128;\r\n            if (x & 0x200000000 > 0)\r\n                result = (result * 0x10000000162E42FF0999CE3541B9FFFCF) >> 128;\r\n            if (x & 0x100000000 > 0)\r\n                result = (result * 0x100000000B17217F80F4EF5AADDA45554) >> 128;\r\n            if (x & 0x80000000 > 0)\r\n                result = (result * 0x10000000058B90BFBF8479BD5A81B51AD) >> 128;\r\n            if (x & 0x40000000 > 0)\r\n                result = (result * 0x1000000002C5C85FDF84BD62AE30A74CC) >> 128;\r\n            if (x & 0x20000000 > 0)\r\n                result = (result * 0x100000000162E42FEFB2FED257559BDAA) >> 128;\r\n            if (x & 0x10000000 > 0)\r\n                result = (result * 0x1000000000B17217F7D5A7716BBA4A9AE) >> 128;\r\n            if (x & 0x8000000 > 0)\r\n                result = (result * 0x100000000058B90BFBE9DDBAC5E109CCE) >> 128;\r\n            if (x & 0x4000000 > 0)\r\n                result = (result * 0x10000000002C5C85FDF4B15DE6F17EB0D) >> 128;\r\n            if (x & 0x2000000 > 0)\r\n                result = (result * 0x1000000000162E42FEFA494F1478FDE05) >> 128;\r\n            if (x & 0x1000000 > 0)\r\n                result = (result * 0x10000000000B17217F7D20CF927C8E94C) >> 128;\r\n            if (x & 0x800000 > 0)\r\n                result = (result * 0x1000000000058B90BFBE8F71CB4E4B33D) >> 128;\r\n            if (x & 0x400000 > 0)\r\n                result = (result * 0x100000000002C5C85FDF477B662B26945) >> 128;\r\n            if (x & 0x200000 > 0)\r\n                result = (result * 0x10000000000162E42FEFA3AE53369388C) >> 128;\r\n            if (x & 0x100000 > 0)\r\n                result = (result * 0x100000000000B17217F7D1D351A389D40) >> 128;\r\n            if (x & 0x80000 > 0)\r\n                result = (result * 0x10000000000058B90BFBE8E8B2D3D4EDE) >> 128;\r\n            if (x & 0x40000 > 0)\r\n                result = (result * 0x1000000000002C5C85FDF4741BEA6E77E) >> 128;\r\n            if (x & 0x20000 > 0)\r\n                result = (result * 0x100000000000162E42FEFA39FE95583C2) >> 128;\r\n            if (x & 0x10000 > 0)\r\n                result = (result * 0x1000000000000B17217F7D1CFB72B45E1) >> 128;\r\n            if (x & 0x8000 > 0)\r\n                result = (result * 0x100000000000058B90BFBE8E7CC35C3F0) >> 128;\r\n            if (x & 0x4000 > 0)\r\n                result = (result * 0x10000000000002C5C85FDF473E242EA38) >> 128;\r\n            if (x & 0x2000 > 0)\r\n                result = (result * 0x1000000000000162E42FEFA39F02B772C) >> 128;\r\n            if (x & 0x1000 > 0)\r\n                result = (result * 0x10000000000000B17217F7D1CF7D83C1A) >> 128;\r\n            if (x & 0x800 > 0)\r\n                result = (result * 0x1000000000000058B90BFBE8E7BDCBE2E) >> 128;\r\n            if (x & 0x400 > 0)\r\n                result = (result * 0x100000000000002C5C85FDF473DEA871F) >> 128;\r\n            if (x & 0x200 > 0)\r\n                result = (result * 0x10000000000000162E42FEFA39EF44D91) >> 128;\r\n            if (x & 0x100 > 0)\r\n                result = (result * 0x100000000000000B17217F7D1CF79E949) >> 128;\r\n            if (x & 0x80 > 0)\r\n                result = (result * 0x10000000000000058B90BFBE8E7BCE544) >> 128;\r\n            if (x & 0x40 > 0)\r\n                result = (result * 0x1000000000000002C5C85FDF473DE6ECA) >> 128;\r\n            if (x & 0x20 > 0)\r\n                result = (result * 0x100000000000000162E42FEFA39EF366F) >> 128;\r\n            if (x & 0x10 > 0)\r\n                result = (result * 0x1000000000000000B17217F7D1CF79AFA) >> 128;\r\n            if (x & 0x8 > 0)\r\n                result = (result * 0x100000000000000058B90BFBE8E7BCD6D) >> 128;\r\n            if (x & 0x4 > 0)\r\n                result = (result * 0x10000000000000002C5C85FDF473DE6B2) >> 128;\r\n            if (x & 0x2 > 0)\r\n                result = (result * 0x1000000000000000162E42FEFA39EF358) >> 128;\r\n            if (x & 0x1 > 0)\r\n                result = (result * 0x10000000000000000B17217F7D1CF79AB) >> 128;\r\n\r\n            result >>= uint256(int256(63 - (x >> 64)));\r\n            require(result <= uint256(int256(MAX_64x64)));\r\n\r\n            return int128(int256(result));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate natural exponent of x.  Revert on overflow.\r\n     *\r\n     * @param x signed 64.64-bit fixed point number\r\n     * @return signed 64.64-bit fixed point number\r\n     */\r\n    function exp(int128 x) internal pure returns (int128) {\r\n        unchecked {\r\n            require(x < 0x400000000000000000); // Overflow\r\n\r\n            if (x < -0x400000000000000000) return 0; // Underflow\r\n\r\n            return\r\n                exp_2(\r\n                    int128(\r\n                        (int256(x) * 0x171547652B82FE1777D0FFDA0D23A7D12) >> 128\r\n                    )\r\n                );\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate x / y rounding towards zero, where x and y are unsigned 256-bit\r\n     * integer numbers.  Revert on overflow or when y is zero.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @param y unsigned 256-bit integer number\r\n     * @return unsigned 64.64-bit fixed point number\r\n     */\r\n    function divuu(uint256 x, uint256 y) private pure returns (uint128) {\r\n        unchecked {\r\n            require(y != 0);\r\n\r\n            uint256 result;\r\n\r\n            if (x <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)\r\n                result = (x << 64) / y;\r\n            else {\r\n                uint256 msb = 192;\r\n                uint256 xc = x >> 192;\r\n                if (xc >= 0x100000000) {\r\n                    xc >>= 32;\r\n                    msb += 32;\r\n                }\r\n                if (xc >= 0x10000) {\r\n                    xc >>= 16;\r\n                    msb += 16;\r\n                }\r\n                if (xc >= 0x100) {\r\n                    xc >>= 8;\r\n                    msb += 8;\r\n                }\r\n                if (xc >= 0x10) {\r\n                    xc >>= 4;\r\n                    msb += 4;\r\n                }\r\n                if (xc >= 0x4) {\r\n                    xc >>= 2;\r\n                    msb += 2;\r\n                }\r\n                if (xc >= 0x2) msb += 1; // No need to shift xc anymore\r\n\r\n                result = (x << (255 - msb)) / (((y - 1) >> (msb - 191)) + 1);\r\n                require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n                uint256 hi = result * (y >> 128);\r\n                uint256 lo = result * (y & 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n\r\n                uint256 xh = x >> 192;\r\n                uint256 xl = x << 64;\r\n\r\n                if (xl < lo) xh -= 1;\r\n                xl -= lo; // We rely on overflow behavior here\r\n                lo = hi << 128;\r\n                if (xl < lo) xh -= 1;\r\n                xl -= lo; // We rely on overflow behavior here\r\n\r\n                assert(xh == hi >> 128);\r\n\r\n                result += xl / y;\r\n            }\r\n\r\n            require(result <= 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF);\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate sqrt (x) rounding down, where x is unsigned 256-bit integer\r\n     * number.\r\n     *\r\n     * @param x unsigned 256-bit integer number\r\n     * @return unsigned 128-bit integer number\r\n     */\r\n    function sqrtu(uint256 x) private pure returns (uint128) {\r\n        unchecked {\r\n            if (x == 0) return 0;\r\n            else {\r\n                uint256 xx = x;\r\n                uint256 r = 1;\r\n                if (xx >= 0x100000000000000000000000000000000) {\r\n                    xx >>= 128;\r\n                    r <<= 64;\r\n                }\r\n                if (xx >= 0x10000000000000000) {\r\n                    xx >>= 64;\r\n                    r <<= 32;\r\n                }\r\n                if (xx >= 0x100000000) {\r\n                    xx >>= 32;\r\n                    r <<= 16;\r\n                }\r\n                if (xx >= 0x10000) {\r\n                    xx >>= 16;\r\n                    r <<= 8;\r\n                }\r\n                if (xx >= 0x100) {\r\n                    xx >>= 8;\r\n                    r <<= 4;\r\n                }\r\n                if (xx >= 0x10) {\r\n                    xx >>= 4;\r\n                    r <<= 2;\r\n                }\r\n                if (xx >= 0x8) {\r\n                    r <<= 1;\r\n                }\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1;\r\n                r = (r + x / r) >> 1; // Seven iterations should be enough\r\n                uint256 r1 = x / r;\r\n                return uint128(r < r1 ? r : r1);\r\n            }\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/space/YieldMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity 0.8.6;\r\n\r\nimport \"./Math64x64.sol\";\r\n\r\nlibrary Exp64x64 {\r\n    /**\r\n     * Raise given number x into power specified as a simple fraction y/z and then\r\n     * multiply the result by the normalization factor 2^(128 * (1 - y/z)).\r\n     * Revert if z is zero, or if both x and y are zeros.\r\n     *\r\n     * @param x number to raise into given power y/z\r\n     * @param y numerator of the power to raise x into\r\n     * @param z denominator of the power to raise x into\r\n     * @return x raised into power y/z and then multiplied by 2^(128 * (1 - y/z))\r\n     */\r\n    function pow(\r\n        uint128 x,\r\n        uint128 y,\r\n        uint128 z\r\n    ) internal pure returns (uint128) {\r\n        unchecked {\r\n            require(z != 0);\r\n\r\n            if (x == 0) {\r\n                require(y != 0);\r\n                return 0;\r\n            } else {\r\n                uint256 l = (uint256(\r\n                    0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - log_2(x)\r\n                ) * y) / z;\r\n                if (l > 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF) return 0;\r\n                else\r\n                    return\r\n                        pow_2(uint128(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF - l));\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate base 2 logarithm of an unsigned 128-bit integer number.  Revert\r\n     * in case x is zero.\r\n     *\r\n     * @param x number to calculate base 2 logarithm of\r\n     * @return base 2 logarithm of x, multiplied by 2^121\r\n     */\r\n    function log_2(uint128 x) internal pure returns (uint128) {\r\n        unchecked {\r\n            require(x != 0);\r\n\r\n            uint256 b = x;\r\n\r\n            uint256 l = 0xFE000000000000000000000000000000;\r\n\r\n            if (b < 0x10000000000000000) {\r\n                l -= 0x80000000000000000000000000000000;\r\n                b <<= 64;\r\n            }\r\n            if (b < 0x1000000000000000000000000) {\r\n                l -= 0x40000000000000000000000000000000;\r\n                b <<= 32;\r\n            }\r\n            if (b < 0x10000000000000000000000000000) {\r\n                l -= 0x20000000000000000000000000000000;\r\n                b <<= 16;\r\n            }\r\n            if (b < 0x1000000000000000000000000000000) {\r\n                l -= 0x10000000000000000000000000000000;\r\n                b <<= 8;\r\n            }\r\n            if (b < 0x10000000000000000000000000000000) {\r\n                l -= 0x8000000000000000000000000000000;\r\n                b <<= 4;\r\n            }\r\n            if (b < 0x40000000000000000000000000000000) {\r\n                l -= 0x4000000000000000000000000000000;\r\n                b <<= 2;\r\n            }\r\n            if (b < 0x80000000000000000000000000000000) {\r\n                l -= 0x2000000000000000000000000000000;\r\n                b <<= 1;\r\n            }\r\n\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x1000000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x800000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x400000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x200000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x100000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x80000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x40000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x20000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x10000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x8000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x4000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x2000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x1000000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x800000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x400000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x200000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x100000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x80000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x40000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x20000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x10000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x8000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x4000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x2000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x1000000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x800000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x400000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x200000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x100000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x80000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x40000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x20000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x10000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x8000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x4000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x2000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x1000000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x800000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x400000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x200000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x100000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x80000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x40000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x20000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x10000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x8000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x4000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x2000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x1000000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x800000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x400000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x200000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x100000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x80000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x40000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x20000000000000000;\r\n            }\r\n            b = (b * b) >> 127;\r\n            if (b >= 0x100000000000000000000000000000000) {\r\n                b >>= 1;\r\n                l |= 0x10000000000000000;\r\n            } /*\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x1000;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x800;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x400;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x200;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x100;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x80;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x40;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x20;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x10;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x8;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x4;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) {b >>= 1; l |= 0x2;}\r\n      b = b * b >> 127; if(b >= 0x100000000000000000000000000000000) l |= 0x1; */\r\n\r\n            return uint128(l);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate 2 raised into given power.\r\n     *\r\n     * @param x power to raise 2 into, multiplied by 2^121\r\n     * @return 2 raised into given power\r\n     */\r\n    function pow_2(uint128 x) internal pure returns (uint128) {\r\n        unchecked {\r\n            uint256 r = 0x80000000000000000000000000000000;\r\n            if (x & 0x1000000000000000000000000000000 > 0)\r\n                r = (r * 0xb504f333f9de6484597d89b3754abe9f) >> 127;\r\n            if (x & 0x800000000000000000000000000000 > 0)\r\n                r = (r * 0x9837f0518db8a96f46ad23182e42f6f6) >> 127;\r\n            if (x & 0x400000000000000000000000000000 > 0)\r\n                r = (r * 0x8b95c1e3ea8bd6e6fbe4628758a53c90) >> 127;\r\n            if (x & 0x200000000000000000000000000000 > 0)\r\n                r = (r * 0x85aac367cc487b14c5c95b8c2154c1b2) >> 127;\r\n            if (x & 0x100000000000000000000000000000 > 0)\r\n                r = (r * 0x82cd8698ac2ba1d73e2a475b46520bff) >> 127;\r\n            if (x & 0x80000000000000000000000000000 > 0)\r\n                r = (r * 0x8164d1f3bc0307737be56527bd14def4) >> 127;\r\n            if (x & 0x40000000000000000000000000000 > 0)\r\n                r = (r * 0x80b1ed4fd999ab6c25335719b6e6fd20) >> 127;\r\n            if (x & 0x20000000000000000000000000000 > 0)\r\n                r = (r * 0x8058d7d2d5e5f6b094d589f608ee4aa2) >> 127;\r\n            if (x & 0x10000000000000000000000000000 > 0)\r\n                r = (r * 0x802c6436d0e04f50ff8ce94a6797b3ce) >> 127;\r\n            if (x & 0x8000000000000000000000000000 > 0)\r\n                r = (r * 0x8016302f174676283690dfe44d11d008) >> 127;\r\n            if (x & 0x4000000000000000000000000000 > 0)\r\n                r = (r * 0x800b179c82028fd0945e54e2ae18f2f0) >> 127;\r\n            if (x & 0x2000000000000000000000000000 > 0)\r\n                r = (r * 0x80058baf7fee3b5d1c718b38e549cb93) >> 127;\r\n            if (x & 0x1000000000000000000000000000 > 0)\r\n                r = (r * 0x8002c5d00fdcfcb6b6566a58c048be1f) >> 127;\r\n            if (x & 0x800000000000000000000000000 > 0)\r\n                r = (r * 0x800162e61bed4a48e84c2e1a463473d9) >> 127;\r\n            if (x & 0x400000000000000000000000000 > 0)\r\n                r = (r * 0x8000b17292f702a3aa22beacca949013) >> 127;\r\n            if (x & 0x200000000000000000000000000 > 0)\r\n                r = (r * 0x800058b92abbae02030c5fa5256f41fe) >> 127;\r\n            if (x & 0x100000000000000000000000000 > 0)\r\n                r = (r * 0x80002c5c8dade4d71776c0f4dbea67d6) >> 127;\r\n            if (x & 0x80000000000000000000000000 > 0)\r\n                r = (r * 0x8000162e44eaf636526be456600bdbe4) >> 127;\r\n            if (x & 0x40000000000000000000000000 > 0)\r\n                r = (r * 0x80000b1721fa7c188307016c1cd4e8b6) >> 127;\r\n            if (x & 0x20000000000000000000000000 > 0)\r\n                r = (r * 0x8000058b90de7e4cecfc487503488bb1) >> 127;\r\n            if (x & 0x10000000000000000000000000 > 0)\r\n                r = (r * 0x800002c5c8678f36cbfce50a6de60b14) >> 127;\r\n            if (x & 0x8000000000000000000000000 > 0)\r\n                r = (r * 0x80000162e431db9f80b2347b5d62e516) >> 127;\r\n            if (x & 0x4000000000000000000000000 > 0)\r\n                r = (r * 0x800000b1721872d0c7b08cf1e0114152) >> 127;\r\n            if (x & 0x2000000000000000000000000 > 0)\r\n                r = (r * 0x80000058b90c1aa8a5c3736cb77e8dff) >> 127;\r\n            if (x & 0x1000000000000000000000000 > 0)\r\n                r = (r * 0x8000002c5c8605a4635f2efc2362d978) >> 127;\r\n            if (x & 0x800000000000000000000000 > 0)\r\n                r = (r * 0x800000162e4300e635cf4a109e3939bd) >> 127;\r\n            if (x & 0x400000000000000000000000 > 0)\r\n                r = (r * 0x8000000b17217ff81bef9c551590cf83) >> 127;\r\n            if (x & 0x200000000000000000000000 > 0)\r\n                r = (r * 0x800000058b90bfdd4e39cd52c0cfa27c) >> 127;\r\n            if (x & 0x100000000000000000000000 > 0)\r\n                r = (r * 0x80000002c5c85fe6f72d669e0e76e411) >> 127;\r\n            if (x & 0x80000000000000000000000 > 0)\r\n                r = (r * 0x8000000162e42ff18f9ad35186d0df28) >> 127;\r\n            if (x & 0x40000000000000000000000 > 0)\r\n                r = (r * 0x80000000b17217f84cce71aa0dcfffe7) >> 127;\r\n            if (x & 0x20000000000000000000000 > 0)\r\n                r = (r * 0x8000000058b90bfc07a77ad56ed22aaa) >> 127;\r\n            if (x & 0x10000000000000000000000 > 0)\r\n                r = (r * 0x800000002c5c85fdfc23cdead40da8d6) >> 127;\r\n            if (x & 0x8000000000000000000000 > 0)\r\n                r = (r * 0x80000000162e42fefc25eb1571853a66) >> 127;\r\n            if (x & 0x4000000000000000000000 > 0)\r\n                r = (r * 0x800000000b17217f7d97f692baacded5) >> 127;\r\n            if (x & 0x2000000000000000000000 > 0)\r\n                r = (r * 0x80000000058b90bfbead3b8b5dd254d7) >> 127;\r\n            if (x & 0x1000000000000000000000 > 0)\r\n                r = (r * 0x8000000002c5c85fdf4eedd62f084e67) >> 127;\r\n            if (x & 0x800000000000000000000 > 0)\r\n                r = (r * 0x800000000162e42fefa58aef378bf586) >> 127;\r\n            if (x & 0x400000000000000000000 > 0)\r\n                r = (r * 0x8000000000b17217f7d24a78a3c7ef02) >> 127;\r\n            if (x & 0x200000000000000000000 > 0)\r\n                r = (r * 0x800000000058b90bfbe9067c93e474a6) >> 127;\r\n            if (x & 0x100000000000000000000 > 0)\r\n                r = (r * 0x80000000002c5c85fdf47b8e5a72599f) >> 127;\r\n            if (x & 0x80000000000000000000 > 0)\r\n                r = (r * 0x8000000000162e42fefa3bdb315934a2) >> 127;\r\n            if (x & 0x40000000000000000000 > 0)\r\n                r = (r * 0x80000000000b17217f7d1d7299b49c46) >> 127;\r\n            if (x & 0x20000000000000000000 > 0)\r\n                r = (r * 0x8000000000058b90bfbe8e9a8d1c4ea0) >> 127;\r\n            if (x & 0x10000000000000000000 > 0)\r\n                r = (r * 0x800000000002c5c85fdf4745969ea76f) >> 127;\r\n            if (x & 0x8000000000000000000 > 0)\r\n                r = (r * 0x80000000000162e42fefa3a0df5373bf) >> 127;\r\n            if (x & 0x4000000000000000000 > 0)\r\n                r = (r * 0x800000000000b17217f7d1cff4aac1e1) >> 127;\r\n            if (x & 0x2000000000000000000 > 0)\r\n                r = (r * 0x80000000000058b90bfbe8e7db95a2f1) >> 127;\r\n            if (x & 0x1000000000000000000 > 0)\r\n                r = (r * 0x8000000000002c5c85fdf473e61ae1f8) >> 127;\r\n            if (x & 0x800000000000000000 > 0)\r\n                r = (r * 0x800000000000162e42fefa39f121751c) >> 127;\r\n            if (x & 0x400000000000000000 > 0)\r\n                r = (r * 0x8000000000000b17217f7d1cf815bb96) >> 127;\r\n            if (x & 0x200000000000000000 > 0)\r\n                r = (r * 0x800000000000058b90bfbe8e7bec1e0d) >> 127;\r\n            if (x & 0x100000000000000000 > 0)\r\n                r = (r * 0x80000000000002c5c85fdf473dee5f17) >> 127;\r\n            if (x & 0x80000000000000000 > 0)\r\n                r = (r * 0x8000000000000162e42fefa39ef5438f) >> 127;\r\n            if (x & 0x40000000000000000 > 0)\r\n                r = (r * 0x80000000000000b17217f7d1cf7a26c8) >> 127;\r\n            if (x & 0x20000000000000000 > 0)\r\n                r = (r * 0x8000000000000058b90bfbe8e7bcf4a4) >> 127;\r\n            if (x & 0x10000000000000000 > 0)\r\n                r = (r * 0x800000000000002c5c85fdf473de72a2) >> 127; /*\r\n      if(x & 0x8000000000000000 > 0) r = r * 0x80000000000000162e42fefa39ef3765 >> 127;\r\n      if(x & 0x4000000000000000 > 0) r = r * 0x800000000000000b17217f7d1cf79b37 >> 127;\r\n      if(x & 0x2000000000000000 > 0) r = r * 0x80000000000000058b90bfbe8e7bcd7d >> 127;\r\n      if(x & 0x1000000000000000 > 0) r = r * 0x8000000000000002c5c85fdf473de6b6 >> 127;\r\n      if(x & 0x800000000000000 > 0) r = r * 0x800000000000000162e42fefa39ef359 >> 127;\r\n      if(x & 0x400000000000000 > 0) r = r * 0x8000000000000000b17217f7d1cf79ac >> 127;\r\n      if(x & 0x200000000000000 > 0) r = r * 0x800000000000000058b90bfbe8e7bcd6 >> 127;\r\n      if(x & 0x100000000000000 > 0) r = r * 0x80000000000000002c5c85fdf473de6a >> 127;\r\n      if(x & 0x80000000000000 > 0) r = r * 0x8000000000000000162e42fefa39ef35 >> 127;\r\n      if(x & 0x40000000000000 > 0) r = r * 0x80000000000000000b17217f7d1cf79a >> 127;\r\n      if(x & 0x20000000000000 > 0) r = r * 0x8000000000000000058b90bfbe8e7bcd >> 127;\r\n      if(x & 0x10000000000000 > 0) r = r * 0x800000000000000002c5c85fdf473de6 >> 127;\r\n      if(x & 0x8000000000000 > 0) r = r * 0x80000000000000000162e42fefa39ef3 >> 127;\r\n      if(x & 0x4000000000000 > 0) r = r * 0x800000000000000000b17217f7d1cf79 >> 127;\r\n      if(x & 0x2000000000000 > 0) r = r * 0x80000000000000000058b90bfbe8e7bc >> 127;\r\n      if(x & 0x1000000000000 > 0) r = r * 0x8000000000000000002c5c85fdf473de >> 127;\r\n      if(x & 0x800000000000 > 0) r = r * 0x800000000000000000162e42fefa39ef >> 127;\r\n      if(x & 0x400000000000 > 0) r = r * 0x8000000000000000000b17217f7d1cf7 >> 127;\r\n      if(x & 0x200000000000 > 0) r = r * 0x800000000000000000058b90bfbe8e7b >> 127;\r\n      if(x & 0x100000000000 > 0) r = r * 0x80000000000000000002c5c85fdf473d >> 127;\r\n      if(x & 0x80000000000 > 0) r = r * 0x8000000000000000000162e42fefa39e >> 127;\r\n      if(x & 0x40000000000 > 0) r = r * 0x80000000000000000000b17217f7d1cf >> 127;\r\n      if(x & 0x20000000000 > 0) r = r * 0x8000000000000000000058b90bfbe8e7 >> 127;\r\n      if(x & 0x10000000000 > 0) r = r * 0x800000000000000000002c5c85fdf473 >> 127;\r\n      if(x & 0x8000000000 > 0) r = r * 0x80000000000000000000162e42fefa39 >> 127;\r\n      if(x & 0x4000000000 > 0) r = r * 0x800000000000000000000b17217f7d1c >> 127;\r\n      if(x & 0x2000000000 > 0) r = r * 0x80000000000000000000058b90bfbe8e >> 127;\r\n      if(x & 0x1000000000 > 0) r = r * 0x8000000000000000000002c5c85fdf47 >> 127;\r\n      if(x & 0x800000000 > 0) r = r * 0x800000000000000000000162e42fefa3 >> 127;\r\n      if(x & 0x400000000 > 0) r = r * 0x8000000000000000000000b17217f7d1 >> 127;\r\n      if(x & 0x200000000 > 0) r = r * 0x800000000000000000000058b90bfbe8 >> 127;\r\n      if(x & 0x100000000 > 0) r = r * 0x80000000000000000000002c5c85fdf4 >> 127;\r\n      if(x & 0x80000000 > 0) r = r * 0x8000000000000000000000162e42fefa >> 127;\r\n      if(x & 0x40000000 > 0) r = r * 0x80000000000000000000000b17217f7d >> 127;\r\n      if(x & 0x20000000 > 0) r = r * 0x8000000000000000000000058b90bfbe >> 127;\r\n      if(x & 0x10000000 > 0) r = r * 0x800000000000000000000002c5c85fdf >> 127;\r\n      if(x & 0x8000000 > 0) r = r * 0x80000000000000000000000162e42fef >> 127;\r\n      if(x & 0x4000000 > 0) r = r * 0x800000000000000000000000b17217f7 >> 127;\r\n      if(x & 0x2000000 > 0) r = r * 0x80000000000000000000000058b90bfb >> 127;\r\n      if(x & 0x1000000 > 0) r = r * 0x8000000000000000000000002c5c85fd >> 127;\r\n      if(x & 0x800000 > 0) r = r * 0x800000000000000000000000162e42fe >> 127;\r\n      if(x & 0x400000 > 0) r = r * 0x8000000000000000000000000b17217f >> 127;\r\n      if(x & 0x200000 > 0) r = r * 0x800000000000000000000000058b90bf >> 127;\r\n      if(x & 0x100000 > 0) r = r * 0x80000000000000000000000002c5c85f >> 127;\r\n      if(x & 0x80000 > 0) r = r * 0x8000000000000000000000000162e42f >> 127;\r\n      if(x & 0x40000 > 0) r = r * 0x80000000000000000000000000b17217 >> 127;\r\n      if(x & 0x20000 > 0) r = r * 0x8000000000000000000000000058b90b >> 127;\r\n      if(x & 0x10000 > 0) r = r * 0x800000000000000000000000002c5c85 >> 127;\r\n      if(x & 0x8000 > 0) r = r * 0x80000000000000000000000000162e42 >> 127;\r\n      if(x & 0x4000 > 0) r = r * 0x800000000000000000000000000b1721 >> 127;\r\n      if(x & 0x2000 > 0) r = r * 0x80000000000000000000000000058b90 >> 127;\r\n      if(x & 0x1000 > 0) r = r * 0x8000000000000000000000000002c5c8 >> 127;\r\n      if(x & 0x800 > 0) r = r * 0x800000000000000000000000000162e4 >> 127;\r\n      if(x & 0x400 > 0) r = r * 0x8000000000000000000000000000b172 >> 127;\r\n      if(x & 0x200 > 0) r = r * 0x800000000000000000000000000058b9 >> 127;\r\n      if(x & 0x100 > 0) r = r * 0x80000000000000000000000000002c5c >> 127;\r\n      if(x & 0x80 > 0) r = r * 0x8000000000000000000000000000162e >> 127;\r\n      if(x & 0x40 > 0) r = r * 0x80000000000000000000000000000b17 >> 127;\r\n      if(x & 0x20 > 0) r = r * 0x8000000000000000000000000000058b >> 127;\r\n      if(x & 0x10 > 0) r = r * 0x800000000000000000000000000002c5 >> 127;\r\n      if(x & 0x8 > 0) r = r * 0x80000000000000000000000000000162 >> 127;\r\n      if(x & 0x4 > 0) r = r * 0x800000000000000000000000000000b1 >> 127;\r\n      if(x & 0x2 > 0) r = r * 0x80000000000000000000000000000058 >> 127;\r\n      if(x & 0x1 > 0) r = r * 0x8000000000000000000000000000002c >> 127; */\r\n\r\n            r >>= 127 - (x >> 121);\r\n\r\n            return uint128(r);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Ethereum smart contract library implementing Yield Math model.\r\n */\r\nlibrary YieldMath {\r\n    using Math64x64 for int128;\r\n    using Math64x64 for uint128;\r\n    using Math64x64 for int256;\r\n    using Math64x64 for uint256;\r\n    using Exp64x64 for uint128;\r\n\r\n    uint128 public constant ONE = 0x10000000000000000; // In 64.64\r\n    uint128 public constant TWO = 0x20000000000000000; // In 64.64\r\n    uint256 public constant MAX = type(uint128).max; // Used for overflow checks\r\n    uint256 public constant VAR = 1e12; // The logarithm math used is not precise to the wei, but can deviate up to 1e12 from the real value.\r\n\r\n    /**\r\n     * Calculate a YieldSpace pool invariant according to the whitepaper\r\n     */\r\n    function invariant(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint256 totalSupply,\r\n        uint128 timeTillMaturity,\r\n        int128 ts\r\n    ) public pure returns (uint128) {\r\n        if (totalSupply == 0) return 0;\r\n\r\n        unchecked {\r\n            // a = (1 - ts * timeTillMaturity)\r\n            int128 a = int128(ONE).sub(ts.mul(timeTillMaturity.fromUInt()));\r\n            require(a > 0, \"YieldMath: Too far from maturity\");\r\n\r\n            uint256 sum = (uint256(baseReserves.pow(uint128(a), ONE)) +\r\n                uint256(fyTokenReserves.pow(uint128(a), ONE))) >> 1;\r\n            require(sum < MAX, \"YieldMath: Sum overflow\");\r\n\r\n            uint256 result = uint256(uint128(sum).pow(ONE, uint128(a))) /\r\n                totalSupply;\r\n            require(result < MAX, \"YieldMath: Result overflow\");\r\n\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the amount of fyToken a user would get for given amount of Base.\r\n     * https://www.desmos.com/calculator/5nf2xuy6yb\r\n     * @param baseReserves base reserves amount\r\n     * @param fyTokenReserves fyToken reserves amount\r\n     * @param baseAmount base amount to be traded\r\n     * @param timeTillMaturity time till maturity in seconds\r\n     * @param ts time till maturity coefficient, multiplied by 2^64\r\n     * @param g fee coefficient, multiplied by 2^64\r\n     * @return the amount of fyToken a user would get for given amount of Base\r\n     */\r\n    function fyTokenOutForBaseIn(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint128 baseAmount,\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) public pure returns (uint128) {\r\n        unchecked {\r\n            uint128 a = _computeA(timeTillMaturity, ts, g);\r\n\r\n            // za = baseReserves ** a\r\n            uint256 za = baseReserves.pow(a, ONE);\r\n\r\n            // ya = fyTokenReserves ** a\r\n            uint256 ya = fyTokenReserves.pow(a, ONE);\r\n\r\n            // zx = baseReserves + baseAmount\r\n            uint256 zx = uint256(baseReserves) + uint256(baseAmount);\r\n            require(zx <= MAX, \"YieldMath: Too much base in\");\r\n\r\n            // zxa = zx ** a\r\n            uint256 zxa = uint128(zx).pow(a, ONE);\r\n\r\n            // sum = za + ya - zxa\r\n            uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\r\n            require(sum <= MAX, \"YieldMath: Insufficient fyToken reserves\");\r\n\r\n            // result = fyTokenReserves - (sum ** (1/a))\r\n            uint256 result = uint256(fyTokenReserves) -\r\n                uint256(uint128(sum).pow(ONE, a));\r\n            require(result <= MAX, \"YieldMath: Rounding induced error\");\r\n\r\n            result = result > VAR ? result - VAR : 0; // Subtract error guard, flooring the result at zero\r\n\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the amount of base a user would get for certain amount of fyToken.\r\n     * https://www.desmos.com/calculator/6jlrre7ybt\r\n     * @param baseReserves base reserves amount\r\n     * @param fyTokenReserves fyToken reserves amount\r\n     * @param fyTokenAmount fyToken amount to be traded\r\n     * @param timeTillMaturity time till maturity in seconds\r\n     * @param ts time till maturity coefficient, multiplied by 2^64\r\n     * @param g fee coefficient, multiplied by 2^64\r\n     * @return the amount of Base a user would get for given amount of fyToken\r\n     */\r\n    function baseOutForFYTokenIn(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint128 fyTokenAmount,\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) public pure returns (uint128) {\r\n        unchecked {\r\n            uint128 a = _computeA(timeTillMaturity, ts, g);\r\n\r\n            // za = baseReserves ** a\r\n            uint256 za = baseReserves.pow(a, ONE);\r\n\r\n            // ya = fyTokenReserves ** a\r\n            uint256 ya = fyTokenReserves.pow(a, ONE);\r\n\r\n            // yx = fyDayReserves + fyTokenAmount\r\n            uint256 yx = uint256(fyTokenReserves) + uint256(fyTokenAmount);\r\n            require(yx <= MAX, \"YieldMath: Too much fyToken in\");\r\n\r\n            // yxa = yx ** a\r\n            uint256 yxa = uint128(yx).pow(a, ONE);\r\n\r\n            // sum = za + ya - yxa\r\n            uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\r\n            require(sum <= MAX, \"YieldMath: Insufficient base reserves\");\r\n\r\n            // result = baseReserves - (sum ** (1/a))\r\n            uint256 result = uint256(baseReserves) -\r\n                uint256(uint128(sum).pow(ONE, a));\r\n            require(result <= MAX, \"YieldMath: Rounding induced error\");\r\n\r\n            result = result > VAR ? result - VAR : 0; // Subtract error guard, flooring the result at zero\r\n\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the amount of fyToken a user could sell for given amount of Base.\r\n     * https://www.desmos.com/calculator/0rgnmtckvy\r\n     * @param baseReserves base reserves amount\r\n     * @param fyTokenReserves fyToken reserves amount\r\n     * @param baseAmount Base amount to be traded\r\n     * @param timeTillMaturity time till maturity in seconds\r\n     * @param ts time till maturity coefficient, multiplied by 2^64\r\n     * @param g fee coefficient, multiplied by 2^64\r\n     * @return the amount of fyToken a user could sell for given amount of Base\r\n     */\r\n    function fyTokenInForBaseOut(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint128 baseAmount,\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) public pure returns (uint128) {\r\n        unchecked {\r\n            uint128 a = _computeA(timeTillMaturity, ts, g);\r\n\r\n            // za = baseReserves ** a\r\n            uint256 za = baseReserves.pow(a, ONE);\r\n\r\n            // ya = fyTokenReserves ** a\r\n            uint256 ya = fyTokenReserves.pow(a, ONE);\r\n\r\n            // zx = baseReserves - baseAmount\r\n            uint256 zx = uint256(baseReserves) - uint256(baseAmount);\r\n            require(zx <= MAX, \"YieldMath: Too much base out\");\r\n\r\n            // zxa = zx ** a\r\n            uint256 zxa = uint128(zx).pow(a, ONE);\r\n\r\n            // sum = za + ya - zxa\r\n            uint256 sum = za + ya - zxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\r\n            require(\r\n                sum <= MAX,\r\n                \"YieldMath: Resulting fyToken reserves too high\"\r\n            );\r\n\r\n            // result = (sum ** (1/a)) - fyTokenReserves\r\n            uint256 result = uint256(uint128(sum).pow(ONE, a)) -\r\n                uint256(fyTokenReserves);\r\n            require(result <= MAX, \"YieldMath: Rounding induced error\");\r\n\r\n            result = result < MAX - VAR ? result + VAR : MAX; // Add error guard, ceiling the result at max\r\n\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the amount of base a user would have to pay for certain amount of fyToken.\r\n     * https://www.desmos.com/calculator/ws5oqj8x5i\r\n     * @param baseReserves Base reserves amount\r\n     * @param fyTokenReserves fyToken reserves amount\r\n     * @param fyTokenAmount fyToken amount to be traded\r\n     * @param timeTillMaturity time till maturity in seconds\r\n     * @param ts time till maturity coefficient, multiplied by 2^64\r\n     * @param g fee coefficient, multiplied by 2^64\r\n     * @return the amount of base a user would have to pay for given amount of\r\n     *         fyToken\r\n     */\r\n    function baseInForFYTokenOut(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint128 fyTokenAmount,\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) public pure returns (uint128) {\r\n        unchecked {\r\n            uint128 a = _computeA(timeTillMaturity, ts, g);\r\n\r\n            // za = baseReserves ** a\r\n            uint256 za = baseReserves.pow(a, ONE);\r\n\r\n            // ya = fyTokenReserves ** a\r\n            uint256 ya = fyTokenReserves.pow(a, ONE);\r\n\r\n            // yx = baseReserves - baseAmount\r\n            uint256 yx = uint256(fyTokenReserves) - uint256(fyTokenAmount);\r\n            require(yx <= MAX, \"YieldMath: Too much fyToken out\");\r\n\r\n            // yxa = yx ** a\r\n            uint256 yxa = uint128(yx).pow(a, ONE);\r\n\r\n            // sum = za + ya - yxa\r\n            uint256 sum = za + ya - yxa; // z < MAX, y < MAX, a < 1. It can only underflow, not overflow.\r\n            require(sum <= MAX, \"YieldMath: Resulting base reserves too high\");\r\n\r\n            // result = (sum ** (1/a)) - baseReserves\r\n            uint256 result = uint256(uint128(sum).pow(ONE, a)) -\r\n                uint256(baseReserves);\r\n            require(result <= MAX, \"YieldMath: Rounding induced error\");\r\n\r\n            result = result < MAX - VAR ? result + VAR : MAX; // Add error guard, ceiling the result at max\r\n\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the max amount of fyTokens that can be bought from the pool without making the interest rate negative.\r\n     * See section 6.3 of the YieldSpace White paper\r\n     * @param baseReserves Base reserves amount\r\n     * @param fyTokenReserves fyToken reserves amount\r\n     * @param timeTillMaturity time till maturity in seconds\r\n     * @param ts time till maturity coefficient, multiplied by 2^64\r\n     * @param g fee coefficient, multiplied by 2^64\r\n     * @return max amount of fyTokens that can be bought from the pool\r\n     */\r\n    function maxFYTokenOut(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) public pure returns (uint128) {\r\n        if (baseReserves == fyTokenReserves) return 0;\r\n        unchecked {\r\n            uint128 a = _computeA(timeTillMaturity, ts, g);\r\n\r\n            // xa = baseReserves ** a\r\n            uint128 xa = baseReserves.pow(a, ONE);\r\n\r\n            // ya = fyTokenReserves ** a\r\n            uint128 ya = fyTokenReserves.pow(a, ONE);\r\n\r\n            int128 xy2 = (xa + ya).divu(TWO);\r\n\r\n            uint256 inaccessible = uint256(uint128(xy2).pow(ONE, a));\r\n            require(inaccessible <= MAX, \"YieldMath: Rounding induced error\");\r\n\r\n            inaccessible = inaccessible < MAX - VAR ? inaccessible + VAR : MAX; // Add error guard, ceiling the result at max\r\n\r\n            return\r\n                uint128(inaccessible) > fyTokenReserves\r\n                    ? 0\r\n                    : fyTokenReserves - uint128(inaccessible);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the max amount of fyTokens that can be sold to into the pool.\r\n     * @param baseReserves Base reserves amount\r\n     * @param fyTokenReserves fyToken reserves amount\r\n     * @param timeTillMaturity time till maturity in seconds\r\n     * @param ts time till maturity coefficient, multiplied by 2^64\r\n     * @param g fee coefficient, multiplied by 2^64\r\n     * @return max amount of fyTokens that can be sold to into the pool\r\n     */\r\n    function maxFYTokenIn(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) public pure returns (uint128) {\r\n        unchecked {\r\n            uint128 b = _computeB(timeTillMaturity, ts, g);\r\n\r\n            // xa = baseReserves ** a\r\n            uint128 xa = baseReserves.pow(b, ONE);\r\n\r\n            // ya = fyTokenReserves ** a\r\n            uint128 ya = fyTokenReserves.pow(b, ONE);\r\n\r\n            uint256 result = (xa + ya).pow(ONE, b) - fyTokenReserves;\r\n            require(result <= MAX, \"YieldMath: Rounding induced error\");\r\n\r\n            result = result > VAR ? result - VAR : 0; // Subtract error guard, flooring the result at zero\r\n\r\n            return uint128(result);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Calculate the max amount of base that can be sold to into the pool without making the interest rate negative.\r\n     * @param baseReserves Base reserves amount\r\n     * @param fyTokenReserves fyToken reserves amount\r\n     * @param timeTillMaturity time till maturity in seconds\r\n     * @param ts time till maturity coefficient, multiplied by 2^64\r\n     * @param g fee coefficient, multiplied by 2^64\r\n     * @return max amount of base that can be sold to into the pool\r\n     */\r\n    function maxBaseIn(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) public pure returns (uint128) {\r\n        uint128 _maxFYTokenOut = maxFYTokenOut(\r\n            baseReserves,\r\n            fyTokenReserves,\r\n            timeTillMaturity,\r\n            ts,\r\n            g\r\n        );\r\n        if (_maxFYTokenOut > 0)\r\n            return\r\n                baseInForFYTokenOut(\r\n                    baseReserves,\r\n                    fyTokenReserves,\r\n                    _maxFYTokenOut,\r\n                    timeTillMaturity,\r\n                    ts,\r\n                    g\r\n                );\r\n        return 0;\r\n    }\r\n\r\n    /**\r\n     * Calculate the max amount of base that can be bought from the pool.\r\n     * @param baseReserves Base reserves amount\r\n     * @param fyTokenReserves fyToken reserves amount\r\n     * @param timeTillMaturity time till maturity in seconds\r\n     * @param ts time till maturity coefficient, multiplied by 2^64\r\n     * @param g fee coefficient, multiplied by 2^64\r\n     * @return max amount of base that can be bought from the pool\r\n     */\r\n    function maxBaseOut(\r\n        uint128 baseReserves,\r\n        uint128 fyTokenReserves,\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) public pure returns (uint128) {\r\n        uint128 _maxFYTokenIn = maxFYTokenIn(\r\n            baseReserves,\r\n            fyTokenReserves,\r\n            timeTillMaturity,\r\n            ts,\r\n            g\r\n        );\r\n        return\r\n            baseOutForFYTokenIn(\r\n                baseReserves,\r\n                fyTokenReserves,\r\n                _maxFYTokenIn,\r\n                timeTillMaturity,\r\n                ts,\r\n                g\r\n            );\r\n    }\r\n\r\n    function _computeA(\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) private pure returns (uint128) {\r\n        unchecked {\r\n            // t = ts * timeTillMaturity\r\n            int128 t = ts.mul(timeTillMaturity.fromUInt());\r\n            require(t >= 0, \"YieldMath: t must be positive\"); // Meaning neither T or ts can be negative\r\n\r\n            // a = (1 - gt)\r\n            int128 a = int128(ONE).sub(g.mul(t));\r\n            require(a > 0, \"YieldMath: Too far from maturity\");\r\n            require(a <= int128(ONE), \"YieldMath: g must be positive\");\r\n\r\n            return uint128(a);\r\n        }\r\n    }\r\n\r\n    function _computeB(\r\n        uint128 timeTillMaturity,\r\n        int128 ts,\r\n        int128 g\r\n    ) private pure returns (uint128) {\r\n        unchecked {\r\n            // t = ts * timeTillMaturity\r\n            int128 t = ts.mul(timeTillMaturity.fromUInt());\r\n            require(t >= 0, \"YieldMath: t must be positive\"); // Meaning neither T or ts can be negative\r\n\r\n            // b = (1 - t/g)\r\n            int128 b = int128(ONE).sub(t.div(g));\r\n            require(b > 0, \"YieldMath: Too far from maturity\");\r\n            require(b <= int128(ONE), \"YieldMath: g must be positive\");\r\n\r\n            return uint128(b);\r\n        }\r\n    }\r\n}\r\n"
    },
    "contracts/space/Pool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20Metadata.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/ERC20Permit.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/SafeERC20Namer.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/MinimalTransferHelper.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U112.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256I256.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU128U112.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU128I128.sol\";\nimport \"@yield-protocol/yieldspace-interfaces/IPool.sol\";\nimport \"@yield-protocol/yieldspace-interfaces/IPoolFactory.sol\";\nimport \"@yield-protocol/vault-interfaces/IFYToken.sol\";\nimport \"./YieldMath.sol\";\n\n\n/// @dev The Pool contract exchanges base for fyToken at a price defined by a specific formula.\ncontract Pool is IPool, ERC20Permit {\n    using CastU256U128 for uint256;\n    using CastU256U112 for uint256;\n    using CastU256I256 for uint256;\n    using CastU128U112 for uint128;\n    using CastU128I128 for uint128;\n    using MinimalTransferHelper for IERC20;\n\n    event Trade(uint32 maturity, address indexed from, address indexed to, int256 bases, int256 fyTokens);\n    event Liquidity(uint32 maturity, address indexed from, address indexed to, address indexed fyTokenTo, int256 bases, int256 fyTokens, int256 poolTokens);\n    event Sync(uint112 baseCached, uint112 fyTokenCached, uint256 cumulativeBalancesRatio);\n\n    int128 public immutable override ts;              // 1 / Seconds in 10 years, in 64.64\n    int128 public immutable override g1;             // To be used when selling base to the pool\n    int128 public immutable override g2;             // To be used when selling fyToken to the pool\n    uint32 public immutable override maturity;\n    uint96 public immutable override scaleFactor;    // Scale up to 18 low decimal tokens to get the right precision in YieldMath\n\n    IERC20 public immutable override base;\n    IFYToken public immutable override fyToken;\n\n    uint112 private baseCached;              // uses single storage slot, accessible via getCache\n    uint112 private fyTokenCached;           // uses single storage slot, accessible via getCache\n    uint32  private blockTimestampLast;      // uses single storage slot, accessible via getCache\n\n    uint256 public cumulativeBalancesRatio;  // Fixed point factor with 27 decimals (ray)\n\n    constructor()\n        ERC20Permit(\n            string(abi.encodePacked(\"Yield \", SafeERC20Namer.tokenName(IPoolFactory(msg.sender).nextFYToken()), \" LP Token\")),\n            string(abi.encodePacked(SafeERC20Namer.tokenSymbol(IPoolFactory(msg.sender).nextFYToken()), \"LP\")),\n            SafeERC20Namer.tokenDecimals(IPoolFactory(msg.sender).nextBase())\n        )\n    {\n        IPoolFactory _factory = IPoolFactory(msg.sender);\n        IFYToken _fyToken = IFYToken(_factory.nextFYToken());\n        IERC20 _base = IERC20(_factory.nextBase());\n        fyToken = _fyToken;\n        base = _base;\n\n        uint256 _maturity = _fyToken.maturity();\n        require (_maturity <= type(uint32).max, \"Pool: Maturity too far in the future\");\n        maturity = uint32(_maturity);\n\n        ts = _factory.ts();\n        g1 = _factory.g1();\n        g2 = _factory.g2();\n\n        scaleFactor = uint96(10 ** (18 - SafeERC20Namer.tokenDecimals(address(_base))));\n    }\n\n    /// @dev Trading can only be done before maturity\n    modifier beforeMaturity() {\n        require(\n            block.timestamp < maturity,\n            \"Pool: Too late\"\n        );\n        _;\n    }\n\n    // ---- Balances management ----\n\n    /// @dev Updates the cache to match the actual balances.\n    function sync() external {\n        _update(_getBaseBalance(), _getFYTokenBalance(), baseCached, fyTokenCached);\n    }\n\n    /// @dev Returns the cached balances & last updated timestamp.\n    /// @return Cached base token balance.\n    /// @return Cached virtual FY token balance.\n    /// @return Timestamp that balances were last cached.\n    function getCache()\n        external view override\n        returns (uint112, uint112, uint32)\n    {\n        return (baseCached, fyTokenCached, blockTimestampLast);\n    }\n\n    /// @dev Returns the \"virtual\" fyToken balance, which is the real balance plus the pool token supply.\n    function getFYTokenBalance()\n        public view override\n        returns(uint112)\n    {\n        return _getFYTokenBalance();\n    }\n\n    /// @dev Returns the base balance\n    function getBaseBalance()\n        public view override\n        returns(uint112)\n    {\n        return _getBaseBalance();\n    }\n\n    /// @dev Returns the \"virtual\" fyToken balance, which is the real balance plus the pool token supply.\n    function _getFYTokenBalance()\n        internal view\n        returns(uint112)\n    {\n        return (fyToken.balanceOf(address(this)) + _totalSupply).u112();\n    }\n\n    /// @dev Returns the base balance\n    function _getBaseBalance()\n        internal view\n        returns(uint112)\n    {\n        return base.balanceOf(address(this)).u112();\n    }\n\n    /// @dev Retrieve any base tokens not accounted for in the cache\n    function retrieveBase(address to)\n        external override\n        returns(uint128 retrieved)\n    {\n        retrieved = _getBaseBalance() - baseCached; // Cache can never be above balances\n        base.safeTransfer(to, retrieved);\n        // Now the current balances match the cache, so no need to update the TWAR\n    }\n\n    /// @dev Retrieve any fyTokens not accounted for in the cache\n    function retrieveFYToken(address to)\n        external override\n        returns(uint128 retrieved)\n    {\n        retrieved = _getFYTokenBalance() - fyTokenCached; // Cache can never be above balances\n        IERC20(address(fyToken)).safeTransfer(to, retrieved);\n        // Now the balances match the cache, so no need to update the TWAR\n    }\n\n    /// @dev Update cache and, on the first call per block, ratio accumulators\n    function _update(uint128 baseBalance, uint128 fyBalance, uint112 _baseCached, uint112 _fyTokenCached) private {\n        uint32 blockTimestamp = uint32(block.timestamp);\n        uint32 timeElapsed = blockTimestamp - blockTimestampLast; // overflow is desired\n        if (timeElapsed > 0 && _baseCached != 0 && _fyTokenCached != 0) {\n            // We multiply by 1e27 here so that r = t * y/x is a fixed point factor with 27 decimals \n            uint256 scaledFYTokenCached = uint256(_fyTokenCached) * 1e27;\n            cumulativeBalancesRatio += scaledFYTokenCached  * timeElapsed / _baseCached;\n        }\n        baseCached = baseBalance.u112();\n        fyTokenCached = fyBalance.u112();\n        blockTimestampLast = blockTimestamp;\n        emit Sync(baseCached, fyTokenCached, cumulativeBalancesRatio);\n    }\n\n    // ---- Liquidity ----\n\n    /// @dev Mint liquidity tokens in exchange for adding base and fyToken\n    /// The amount of liquidity tokens to mint is calculated from the amount of unaccounted for fyToken in this contract.\n    /// A proportional amount of base tokens need to be present in this contract, also unaccounted for.\n    /// @param to Wallet receiving the minted liquidity tokens.\n    /// @param remainder Wallet receiving any surplus base.\n    /// @param minRatio Minimum ratio of base to fyToken in the pool.\n    /// @param maxRatio Maximum ratio of base to fyToken in the pool.\n    /// @return The amount of liquidity tokens minted.\n    function mint(address to, address remainder, uint256 minRatio, uint256 maxRatio)\n        external override\n        returns (uint256, uint256, uint256)\n    {\n        return _mintInternal(to, remainder, 0, minRatio, maxRatio);\n    }\n\n    /// @dev Mint liquidity tokens in exchange for adding only base\n    /// The amount of liquidity tokens is calculated from the amount of fyToken to buy from the pool,\n    /// plus the amount of unaccounted for fyToken in this contract.\n    /// The base tokens need to be present in this contract, unaccounted for.\n    /// @param to Wallet receiving the minted liquidity tokens.\n    /// @param remainder Wallet receiving any surplus base.\n    /// @param fyTokenToBuy Amount of `fyToken` being bought in the Pool, from this we calculate how much base it will be taken in.\n    /// @param minRatio Minimum ratio of base to fyToken in the pool.\n    /// @param maxRatio Maximum ratio of base to fyToken in the pool.\n    /// @return The amount of liquidity tokens minted.\n    function mintWithBase(address to, address remainder, uint256 fyTokenToBuy, uint256 minRatio, uint256 maxRatio)\n        external override\n        returns (uint256, uint256, uint256)\n    {\n        return _mintInternal(to, remainder, fyTokenToBuy, minRatio, maxRatio);\n    }\n\n    /// @dev Mint liquidity tokens, with an optional internal trade to buy fyToken beforehand.\n    /// The amount of liquidity tokens is calculated from the amount of fyToken to buy from the pool,\n    /// plus the amount of unaccounted for fyToken in this contract.\n    /// The base tokens need to be present in this contract, unaccounted for.\n    /// @param to Wallet receiving the minted liquidity tokens.\n    /// @param remainder Wallet receiving any surplus base.\n    /// @param fyTokenToBuy Amount of `fyToken` being bought in the Pool, from this we calculate how much base it will be taken in.\n    /// @param minRatio Minimum ratio of base to fyToken in the pool.\n    /// @param maxRatio Minimum ratio of base to fyToken in the pool.\n    function _mintInternal(address to, address remainder, uint256 fyTokenToBuy, uint256 minRatio, uint256 maxRatio)\n        internal\n        returns (uint256 baseIn, uint256 fyTokenIn, uint256 tokensMinted)\n    {\n        // Gather data\n        uint256 supply = _totalSupply;\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint256 _realFYTokenCached = _fyTokenCached - supply;    // The fyToken cache includes the virtual fyToken, equal to the supply\n        uint256 baseBalance = base.balanceOf(address(this));\n        uint256 fyTokenBalance = fyToken.balanceOf(address(this));\n        uint256 baseAvailable = baseBalance - _baseCached;\n\n        // Check the burn wasn't sandwiched\n        require (\n            _realFYTokenCached == 0 || (\n                uint256(_baseCached) * 1e18 / _realFYTokenCached >= minRatio &&\n                uint256(_baseCached) * 1e18 / _realFYTokenCached <= maxRatio\n            ),\n            \"Pool: Reserves ratio changed\"\n        );\n\n        // Calculate token amounts\n        if (supply == 0) { // Initialize at 1 pool token minted per base token supplied\n            baseIn = baseAvailable;\n            tokensMinted = baseIn;\n        } else if (_realFYTokenCached == 0) { // Edge case, no fyToken in the Pool after initialization\n            baseIn = baseAvailable;\n            tokensMinted = supply * baseIn / _baseCached;\n        } else {\n            // There is an optional virtual trade before the mint\n            uint256 baseToSell;\n            if (fyTokenToBuy > 0) {\n                baseToSell = _buyFYTokenPreview(\n                    fyTokenToBuy.u128(),\n                    _baseCached,\n                    _fyTokenCached\n                ); \n            }\n\n            // We use all the available fyTokens, plus a virtual trade if it happened, surplus is in base tokens\n            fyTokenIn = fyTokenBalance - _realFYTokenCached;\n            tokensMinted = (supply * (fyTokenToBuy + fyTokenIn)) / (_realFYTokenCached - fyTokenToBuy);\n            baseIn = baseToSell + ((_baseCached + baseToSell) * tokensMinted) / supply;\n            require(baseAvailable >= baseIn, \"Pool: Not enough base token in\");\n        }\n\n        // Update TWAR\n        _update(\n            (_baseCached + baseIn).u128(),\n            (_fyTokenCached + fyTokenIn + tokensMinted).u128(), // Account for the \"virtual\" fyToken from the new minted LP tokens\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Execute mint\n        _mint(to, tokensMinted);\n\n        // Return any unused base\n        if (baseAvailable - baseIn > 0) base.safeTransfer(remainder, baseAvailable - baseIn);\n\n        emit Liquidity(maturity, msg.sender, to, address(0), -(baseIn.i256()), -(fyTokenIn.i256()), tokensMinted.i256());\n    }\n\n    /// @dev Burn liquidity tokens in exchange for base and fyToken.\n    /// The liquidity tokens need to be in this contract.\n    /// @param baseTo Wallet receiving the base.\n    /// @param fyTokenTo Wallet receiving the fyToken.\n    /// @param minRatio Minimum ratio of base to fyToken in the pool.\n    /// @param maxRatio Maximum ratio of base to fyToken in the pool.\n    /// @return The amount of tokens burned and returned (tokensBurned, bases, fyTokens).\n    function burn(address baseTo, address fyTokenTo, uint256 minRatio, uint256 maxRatio)\n        external override\n        returns (uint256, uint256, uint256)\n    {\n        return _burnInternal(baseTo, fyTokenTo, false, minRatio, maxRatio);\n    }\n\n    /// @dev Burn liquidity tokens in exchange for base.\n    /// The liquidity provider needs to have called `pool.approve`.\n    /// @param to Wallet receiving the base and fyToken.\n    /// @param minRatio Minimum ratio of base to fyToken in the pool.\n    /// @param maxRatio Minimum ratio of base to fyToken in the pool.\n    /// @return tokensBurned The amount of lp tokens burned.\n    /// @return baseOut The amount of base tokens returned.\n    function burnForBase(address to, uint256 minRatio, uint256 maxRatio)\n        external override\n        returns (uint256 tokensBurned, uint256 baseOut)\n    {\n        (tokensBurned, baseOut, ) = _burnInternal(to, address(0), true, minRatio, maxRatio);\n    }\n\n\n    /// @dev Burn liquidity tokens in exchange for base.\n    /// The liquidity provider needs to have called `pool.approve`.\n    /// @param baseTo Wallet receiving the base.\n    /// @param fyTokenTo Wallet receiving the fyToken.\n    /// @param tradeToBase Whether the resulting fyToken should be traded for base tokens.\n    /// @param minRatio Minimum ratio of base to fyToken in the pool.\n    /// @param maxRatio Minimum ratio of base to fyToken in the pool.\n    /// @return tokensBurned The amount of pool tokens burned.\n    /// @return tokenOut The amount of base tokens returned.\n    /// @return fyTokenOut The amount of fyTokens returned.\n    function _burnInternal(address baseTo, address fyTokenTo, bool tradeToBase, uint256 minRatio, uint256 maxRatio)\n        internal\n        returns (uint256 tokensBurned, uint256 tokenOut, uint256 fyTokenOut)\n    {\n        \n        // Gather data\n        tokensBurned = _balanceOf[address(this)];\n        uint256 supply = _totalSupply;\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint256 _realFYTokenCached = _fyTokenCached - supply;    // The fyToken cache includes the virtual fyToken, equal to the supply\n\n        // Check the burn wasn't sandwiched\n        require (\n            _realFYTokenCached == 0 || (\n                uint256(_baseCached) * 1e18 / _realFYTokenCached >= minRatio &&\n                uint256(_baseCached) * 1e18 / _realFYTokenCached <= maxRatio\n            ),\n            \"Pool: Reserves ratio changed\"\n        );\n\n        // Calculate trade\n        tokenOut = (tokensBurned * _baseCached) / supply;\n        fyTokenOut = (tokensBurned * _realFYTokenCached) / supply;\n\n        if (tradeToBase) {\n            tokenOut += YieldMath.baseOutForFYTokenIn(                      // This is a virtual sell\n                (_baseCached - tokenOut.u128()) * scaleFactor,              // Cache, minus virtual burn\n                (_fyTokenCached - fyTokenOut.u128()) * scaleFactor,         // Cache, minus virtual burn\n                fyTokenOut.u128() * scaleFactor,                            // Sell the virtual fyToken obtained\n                maturity - uint32(block.timestamp),                         // This can't be called after maturity\n                ts,\n                g2\n            ) / scaleFactor;\n            fyTokenOut = 0;\n        }\n\n        // Update TWAR\n        _update(\n            (_baseCached - tokenOut).u128(),\n            (_fyTokenCached - fyTokenOut - tokensBurned).u128(),\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        _burn(address(this), tokensBurned);\n        base.safeTransfer(baseTo, tokenOut);\n        if (fyTokenOut > 0) IERC20(address(fyToken)).safeTransfer(fyTokenTo, fyTokenOut);\n\n        emit Liquidity(maturity, msg.sender, baseTo, fyTokenTo, tokenOut.i256(), fyTokenOut.i256(), -(tokensBurned.i256()));\n    }\n\n    // ---- Trading ----\n\n    /// @dev Sell base for fyToken.\n    /// The trader needs to have transferred the amount of base to sell to the pool before in the same transaction.\n    /// @param to Wallet receiving the fyToken being bought\n    /// @param min Minimm accepted amount of fyToken\n    /// @return Amount of fyToken that will be deposited on `to` wallet\n    function sellBase(address to, uint128 min)\n        external override\n        returns(uint128)\n    {\n        // Calculate trade\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint112 _baseBalance = _getBaseBalance();\n        uint112 _fyTokenBalance = _getFYTokenBalance();\n        uint128 baseIn = _baseBalance - _baseCached;\n        uint128 fyTokenOut = _sellBasePreview(\n            baseIn,\n            _baseCached,\n            _fyTokenBalance\n        );\n\n        // Slippage check\n        require(\n            fyTokenOut >= min,\n            \"Pool: Not enough fyToken obtained\"\n        );\n\n        // Update TWAR\n        _update(\n            _baseBalance,\n            _fyTokenBalance - fyTokenOut,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);\n\n        emit Trade(maturity, msg.sender, to, -(baseIn.i128()), fyTokenOut.i128());\n        return fyTokenOut;\n    }\n\n    /// @dev Returns how much fyToken would be obtained by selling `baseIn` base\n    /// @param baseIn Amount of base hypothetically sold.\n    /// @return Amount of fyToken hypothetically bought.\n    function sellBasePreview(uint128 baseIn)\n        external view override\n        returns(uint128)\n    {\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        return _sellBasePreview(baseIn, _baseCached, _fyTokenCached);\n    }\n\n    /// @dev Returns how much fyToken would be obtained by selling `baseIn` base\n    function _sellBasePreview(\n        uint128 baseIn,\n        uint112 baseBalance,\n        uint112 fyTokenBalance\n    )\n        private view\n        beforeMaturity\n        returns(uint128)\n    {\n        uint128 fyTokenOut = YieldMath.fyTokenOutForBaseIn(\n            baseBalance * scaleFactor,\n            fyTokenBalance * scaleFactor,\n            baseIn * scaleFactor,\n            maturity - uint32(block.timestamp),             // This can't be called after maturity\n            ts,\n            g1\n        ) / scaleFactor;\n\n        require(\n            fyTokenBalance - fyTokenOut >= baseBalance + baseIn,\n            \"Pool: fyToken balance too low\"\n        );\n\n        return fyTokenOut;\n    }\n\n    /// @dev Buy base for fyToken\n    /// The trader needs to have called `fyToken.approve`\n    /// @param to Wallet receiving the base being bought\n    /// @param tokenOut Amount of base being bought that will be deposited in `to` wallet\n    /// @param max Maximum amount of fyToken that will be paid for the trade\n    /// @return Amount of fyToken that will be taken from caller\n    function buyBase(address to, uint128 tokenOut, uint128 max)\n        external override\n        returns(uint128)\n    {\n        // Calculate trade\n        uint128 fyTokenBalance = _getFYTokenBalance();\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint128 fyTokenIn = _buyBasePreview(\n            tokenOut,\n            _baseCached,\n            _fyTokenCached\n        );\n        require(\n            fyTokenBalance - _fyTokenCached >= fyTokenIn,\n            \"Pool: Not enough fyToken in\"\n        );\n\n        // Slippage check\n        require(\n            fyTokenIn <= max,\n            \"Pool: Too much fyToken in\"\n        );\n\n        // Update TWAR\n        _update(\n            _baseCached - tokenOut,\n            _fyTokenCached + fyTokenIn,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        base.safeTransfer(to, tokenOut);\n\n        emit Trade(maturity, msg.sender, to, tokenOut.i128(), -(fyTokenIn.i128()));\n        return fyTokenIn;\n    }\n\n    /// @dev Returns how much fyToken would be required to buy `tokenOut` base.\n    /// @param tokenOut Amount of base hypothetically desired.\n    /// @return Amount of fyToken hypothetically required.\n    function buyBasePreview(uint128 tokenOut)\n        external view override\n        returns(uint128)\n    {\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        return _buyBasePreview(tokenOut, _baseCached, _fyTokenCached);\n    }\n\n    /// @dev Returns how much fyToken would be required to buy `tokenOut` base.\n    function _buyBasePreview(\n        uint128 tokenOut,\n        uint112 baseBalance,\n        uint112 fyTokenBalance\n    )\n        private view\n        beforeMaturity\n        returns(uint128)\n    {\n        return YieldMath.fyTokenInForBaseOut(\n            baseBalance * scaleFactor,\n            fyTokenBalance * scaleFactor,\n            tokenOut * scaleFactor,\n            maturity - uint32(block.timestamp),             // This can't be called after maturity\n            ts,\n            g2\n        ) / scaleFactor;\n    }\n\n    /// @dev Sell fyToken for base\n    /// The trader needs to have transferred the amount of fyToken to sell to the pool before in the same transaction.\n    /// @param to Wallet receiving the base being bought\n    /// @param min Minimm accepted amount of base\n    /// @return Amount of base that will be deposited on `to` wallet\n    function sellFYToken(address to, uint128 min)\n        external override\n        returns(uint128)\n    {\n        // Calculate trade\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint112 _fyTokenBalance = _getFYTokenBalance();\n        uint112 _baseBalance = _getBaseBalance();\n        uint128 fyTokenIn = _fyTokenBalance - _fyTokenCached;\n        uint128 baseOut = _sellFYTokenPreview(\n            fyTokenIn,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Slippage check\n        require(\n            baseOut >= min,\n            \"Pool: Not enough base obtained\"\n        );\n\n        // Update TWAR\n        _update(\n            _baseBalance - baseOut,\n            _fyTokenBalance,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        base.safeTransfer(to, baseOut);\n\n        emit Trade(maturity, msg.sender, to, baseOut.i128(), -(fyTokenIn.i128()));\n        return baseOut;\n    }\n\n    /// @dev Returns how much base would be obtained by selling `fyTokenIn` fyToken.\n    /// @param fyTokenIn Amount of fyToken hypothetically sold.\n    /// @return Amount of base hypothetically bought.\n    function sellFYTokenPreview(uint128 fyTokenIn)\n        external view override\n        returns(uint128)\n    {\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        return _sellFYTokenPreview(fyTokenIn, _baseCached, _fyTokenCached);\n    }\n\n    /// @dev Returns how much base would be obtained by selling `fyTokenIn` fyToken.\n    function _sellFYTokenPreview(\n        uint128 fyTokenIn,\n        uint112 baseBalance,\n        uint112 fyTokenBalance\n    )\n        private view\n        beforeMaturity\n        returns(uint128)\n    {\n        return YieldMath.baseOutForFYTokenIn(\n            baseBalance * scaleFactor,\n            fyTokenBalance * scaleFactor,\n            fyTokenIn * scaleFactor,\n            maturity - uint32(block.timestamp),             // This can't be called after maturity\n            ts,\n            g2\n        ) / scaleFactor;\n    }\n\n    /// @dev Buy fyToken for base\n    /// The trader needs to have called `base.approve`\n    /// @param to Wallet receiving the fyToken being bought\n    /// @param fyTokenOut Amount of fyToken being bought that will be deposited in `to` wallet\n    /// @param max Maximum amount of base token that will be paid for the trade\n    /// @return Amount of base that will be taken from caller's wallet\n    function buyFYToken(address to, uint128 fyTokenOut, uint128 max)\n        external override\n        returns(uint128)\n    {\n        // Calculate trade\n        uint128 baseBalance = _getBaseBalance();\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        uint128 baseIn = _buyFYTokenPreview(\n            fyTokenOut,\n            _baseCached,\n            _fyTokenCached\n        );\n        require(\n            baseBalance - _baseCached >= baseIn,\n            \"Pool: Not enough base token in\"\n        );\n\n        // Slippage check\n        require(\n            baseIn <= max,\n            \"Pool: Too much base token in\"\n        );\n\n        // Update TWAR\n        _update(\n            _baseCached + baseIn,\n            _fyTokenCached - fyTokenOut,\n            _baseCached,\n            _fyTokenCached\n        );\n\n        // Transfer assets\n        IERC20(address(fyToken)).safeTransfer(to, fyTokenOut);\n\n        emit Trade(maturity, msg.sender, to, -(baseIn.i128()), fyTokenOut.i128());\n        return baseIn;\n    }\n\n    /// @dev Returns how much base would be required to buy `fyTokenOut` fyToken.\n    /// @param fyTokenOut Amount of fyToken hypothetically desired.\n    /// @return Amount of base hypothetically required.\n    function buyFYTokenPreview(uint128 fyTokenOut)\n        external view override\n        returns(uint128)\n    {\n        (uint112 _baseCached, uint112 _fyTokenCached) =\n            (baseCached, fyTokenCached);\n        return _buyFYTokenPreview(fyTokenOut, _baseCached, _fyTokenCached);\n    }\n\n    /// @dev Returns how much base would be required to buy `fyTokenOut` fyToken.\n    function _buyFYTokenPreview(\n        uint128 fyTokenOut,\n        uint128 baseBalance,\n        uint128 fyTokenBalance\n    )\n        private view\n        beforeMaturity\n        returns(uint128)\n    {\n        uint128 baseIn = YieldMath.baseInForFYTokenOut(\n            baseBalance * scaleFactor,\n            fyTokenBalance * scaleFactor,\n            fyTokenOut * scaleFactor,\n            maturity - uint32(block.timestamp),             // This can't be called after maturity\n            ts,\n            g1\n        ) / scaleFactor;\n\n        require(\n            fyTokenBalance - fyTokenOut >= baseBalance + baseIn,\n            \"Pool: fyToken balance too low\"\n        );\n\n        return baseIn;\n    }\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/token/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}"
    },
    "@yield-protocol/utils-v2/contracts/token/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/master/contracts/token/ERC20/extensions/IERC20Metadata.sol\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n */\ninterface IERC20Metadata is IERC20 {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}"
    },
    "@yield-protocol/utils-v2/contracts/token/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/blob/53516bc555a454862470e7860a9b5254db4d00f5/contracts/token/ERC20/ERC20Permit.sol\npragma solidity ^0.8.0;\n\nimport \"./ERC20.sol\";\nimport \"./IERC2612.sol\";\n\n/**\n * @dev Extension of {ERC20} that allows token holders to use their tokens\n * without sending any transactions by setting {IERC20-allowance} with a\n * signature using the {permit} method, and then spend them via\n * {IERC20-transferFrom}.\n *\n * The {permit} signature mechanism conforms to the {IERC2612} interface.\n */\nabstract contract ERC20Permit is ERC20, IERC2612 {\n    mapping (address => uint256) public override nonces;\n\n    bytes32 public immutable PERMIT_TYPEHASH = keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    bytes32 private immutable _DOMAIN_SEPARATOR;\n    uint256 public immutable deploymentChainId;\n\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) ERC20(name_, symbol_, decimals_) {\n        deploymentChainId = block.chainid;\n        _DOMAIN_SEPARATOR = _calculateDomainSeparator(block.chainid);\n    }\n\n    /// @dev Calculate the DOMAIN_SEPARATOR.\n    function _calculateDomainSeparator(uint256 chainId) private view returns (bytes32) {\n        return keccak256(\n            abi.encode(\n                keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"),\n                keccak256(bytes(name)),\n                keccak256(bytes(version())),\n                chainId,\n                address(this)\n            )\n        );\n    }\n\n    /// @dev Return the DOMAIN_SEPARATOR.\n    function DOMAIN_SEPARATOR() external view returns (bytes32) {\n        return block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid);\n    }\n\n    /// @dev Setting the version as a function so that it can be overriden\n    function version() public pure virtual returns(string memory) { return \"1\"; }\n\n    /**\n     * @dev See {IERC2612-permit}.\n     *\n     * In cases where the free option is not a concern, deadline can simply be\n     * set to uint(-1), so it should be seen as an optional parameter\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external virtual override {\n        require(deadline >= block.timestamp, \"ERC20Permit: expired deadline\");\n\n        bytes32 hashStruct = keccak256(\n            abi.encode(\n                PERMIT_TYPEHASH,\n                owner,\n                spender,\n                amount,\n                nonces[owner]++,\n                deadline\n            )\n        );\n\n        bytes32 hash = keccak256(\n            abi.encodePacked(\n                \"\\x19\\x01\",\n                block.chainid == deploymentChainId ? _DOMAIN_SEPARATOR : _calculateDomainSeparator(block.chainid),\n                hashStruct\n            )\n        );\n\n        address signer = ecrecover(hash, v, r, s);\n        require(\n            signer != address(0) && signer == owner,\n            \"ERC20Permit: invalid signature\"\n        );\n\n        _setAllowance(owner, spender, amount);\n    }\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/token/SafeERC20Namer.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nimport \"../token/IERC20Metadata.sol\";\nimport \"../utils/AddressStringUtil.sol\";\n\n// produces token descriptors from inconsistent or absent ERC20 symbol implementations that can return string or bytes32\n// this library will always produce a string symbol to represent the token\nlibrary SafeERC20Namer {\n    function bytes32ToString(bytes32 x) private pure returns (string memory) {\n        bytes memory bytesString = new bytes(32);\n        uint256 charCount = 0;\n        for (uint256 j = 0; j < 32; j++) {\n            bytes1 char = x[j];\n            if (char != 0) {\n                bytesString[charCount] = char;\n                charCount++;\n            }\n        }\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 j = 0; j < charCount; j++) {\n            bytesStringTrimmed[j] = bytesString[j];\n        }\n        return string(bytesStringTrimmed);\n    }\n\n    // assumes the data is in position 2\n    function parseStringData(bytes memory b) private pure returns (string memory) {\n        uint256 charCount = 0;\n        // first parse the charCount out of the data\n        for (uint256 i = 32; i < 64; i++) {\n            charCount <<= 8;\n            charCount += uint8(b[i]);\n        }\n\n        bytes memory bytesStringTrimmed = new bytes(charCount);\n        for (uint256 i = 0; i < charCount; i++) {\n            bytesStringTrimmed[i] = b[i + 64];\n        }\n\n        return string(bytesStringTrimmed);\n    }\n\n    // uses a heuristic to produce a token name from the address\n    // the heuristic returns the full hex of the address string in upper case\n    function addressToName(address token) private pure returns (string memory) {\n        return AddressStringUtil.toAsciiString(token, 40);\n    }\n\n    // uses a heuristic to produce a token symbol from the address\n    // the heuristic returns the first 6 hex of the address string in upper case\n    function addressToSymbol(address token) private pure returns (string memory) {\n        return AddressStringUtil.toAsciiString(token, 6);\n    }\n\n    // calls an external view token contract method that returns a symbol or name, and parses the output into a string\n    function callAndParseStringReturn(address token, bytes4 selector) private view returns (string memory) {\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(selector));\n        // if not implemented, or returns empty data, return empty string\n        if (!success || data.length == 0) {\n            return \"\";\n        }\n        // bytes32 data always has length 32\n        if (data.length == 32) {\n            bytes32 decoded = abi.decode(data, (bytes32));\n            return bytes32ToString(decoded);\n        } else if (data.length > 64) {\n            return abi.decode(data, (string));\n        }\n        return \"\";\n    }\n\n    // attempts to extract the token symbol. if it does not implement symbol, returns a symbol derived from the address\n    function tokenSymbol(address token) public view returns (string memory) {\n        string memory symbol = callAndParseStringReturn(token, IERC20Metadata.symbol.selector);\n        if (bytes(symbol).length == 0) {\n            // fallback to 6 uppercase hex of address\n            return addressToSymbol(token);\n        }\n        return symbol;\n    }\n\n    // attempts to extract the token name. if it does not implement name, returns a name derived from the address\n    function tokenName(address token) public view returns (string memory) {\n        string memory name = callAndParseStringReturn(token, IERC20Metadata.name.selector);\n        if (bytes(name).length == 0) {\n            // fallback to full hex of address\n            return addressToName(token);\n        }\n        return name;\n    }\n\n    /// @notice Provides a safe ERC20.decimals version which returns '18' as fallback value.\n    /// @param token The address of the ERC-20 token contract.\n    /// @return (uint8) Token decimals.\n    function tokenDecimals(address token) public view returns (uint8) {\n        (bool success, bytes memory data) = token.staticcall(abi.encodeWithSelector(IERC20Metadata.decimals.selector));\n        return success && data.length == 32 ? abi.decode(data, (uint8)) : 18;\n    }\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/token/MinimalTransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\n\npragma solidity >=0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../utils/RevertMsgExtractor.sol\";\n\n\n// helper methods for transferring ERC20 tokens that do not consistently return true/false\nlibrary MinimalTransferHelper {\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with the underlying revert message if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastU256U128 {\n    /// @dev Safely cast an uint256 to an uint128\n    function u128(uint256 x) internal pure returns (uint128 y) {\n        require (x <= type(uint128).max, \"Cast overflow\");\n        y = uint128(x);\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastU256U112.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastU256U112 {\n    /// @dev Safely cast an uint256 to an uint112\n    function u112(uint256 x) internal pure returns (uint112 y) {\n        require (x <= type(uint112).max, \"Cast overflow\");\n        y = uint112(x);\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastU256I256.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastU256I256 {\n    /// @dev Safely cast an uint256 to an int256\n    function i256(uint256 x) internal pure returns (int256 y) {\n        require (x <= uint256(type(int256).max), \"Cast overflow\");\n        y = int256(x);\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastU128U112.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastU128U112 {\n    /// @dev Safely cast an uint128 to an uint112\n    function u112(uint128 x) internal pure returns (uint112 y) {\n        require (x <= uint128(type(uint112).max), \"Cast overflow\");\n        y = uint112(x);\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastU128I128.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastU128I128 {\n    /// @dev Safely cast an uint128 to an int128\n    function i128(uint128 x) internal pure returns (int128 y) {\n        require (x <= uint128(type(int128).max), \"Cast overflow\");\n        y = int128(x);\n    }\n}"
    },
    "@yield-protocol/yieldspace-interfaces/IPool.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.8.0;\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC2612.sol\";\nimport \"@yield-protocol/vault-interfaces/IFYToken.sol\";\n\n\ninterface IPool is IERC20, IERC2612 {\n    function ts() external view returns(int128);\n    function g1() external view returns(int128);\n    function g2() external view returns(int128);\n    function maturity() external view returns(uint32);\n    function scaleFactor() external view returns(uint96);\n    function getCache() external view returns (uint112, uint112, uint32);\n    function base() external view returns(IERC20);\n    function fyToken() external view returns(IFYToken);\n    function getBaseBalance() external view returns(uint112);\n    function getFYTokenBalance() external view returns(uint112);\n    function retrieveBase(address to) external returns(uint128 retrieved);\n    function retrieveFYToken(address to) external returns(uint128 retrieved);\n    function sellBase(address to, uint128 min) external returns(uint128);\n    function buyBase(address to, uint128 baseOut, uint128 max) external returns(uint128);\n    function sellFYToken(address to, uint128 min) external returns(uint128);\n    function buyFYToken(address to, uint128 fyTokenOut, uint128 max) external returns(uint128);\n    function sellBasePreview(uint128 baseIn) external view returns(uint128);\n    function buyBasePreview(uint128 baseOut) external view returns(uint128);\n    function sellFYTokenPreview(uint128 fyTokenIn) external view returns(uint128);\n    function buyFYTokenPreview(uint128 fyTokenOut) external view returns(uint128);\n    function mint(address to, address remainder, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256);\n    function mintWithBase(address to, address remainder, uint256 fyTokenToBuy, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256);\n    function burn(address baseTo, address fyTokenTo, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256, uint256);\n    function burnForBase(address to, uint256 minRatio, uint256 maxRatio) external returns (uint256, uint256);\n}"
    },
    "@yield-protocol/yieldspace-interfaces/IPoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\ninterface IPoolFactory {\n  event PoolCreated(address indexed base, address indexed fyToken, address pool);\n\n  function POOL_BYTECODE_HASH() external pure returns (bytes32);\n  function calculatePoolAddress(address base, address fyToken) external view returns (address);\n  function getPool(address base, address fyToken) external view returns (address);\n  function createPool(address base, address fyToken) external returns (address);\n  function nextBase() external view returns (address);\n  function nextFYToken() external view returns (address);\n  function ts() external view returns (int128);\n  function g1() external view returns (int128);\n  function g2() external view returns (int128);\n}\n"
    },
    "@yield-protocol/vault-interfaces/IFYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\n\n\ninterface IFYToken is IERC20 {\n    /// @dev Asset that is returned on redemption.\n    function underlying() external view returns (address);\n\n    /// @dev Unix time at which redemption of fyToken for underlying are possible\n    function maturity() external view returns (uint256);\n    \n    /// @dev Record price data at maturity\n    function mature() external;\n\n    /// @dev Mint fyToken providing an equal amount of underlying to the protocol\n    function mintWithUnderlying(address to, uint256 amount) external;\n\n    /// @dev Burn fyToken after maturity for an amount of underlying.\n    function redeem(address to, uint256 amount) external returns (uint256);\n\n    /// @dev Mint fyToken.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param to Wallet to mint the fyToken in.\n    /// @param fyTokenAmount Amount of fyToken to mint.\n    function mint(address to, uint256 fyTokenAmount) external;\n\n    /// @dev Burn fyToken.\n    /// This function can only be called by other Yield contracts, not users directly.\n    /// @param from Wallet to burn the fyToken from.\n    /// @param fyTokenAmount Amount of fyToken to burn.\n    function burn(address from, uint256 fyTokenAmount) external;\n}"
    },
    "@yield-protocol/utils-v2/contracts/token/ERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Inspired on token.sol from DappHub. Natspec adpated from OpenZeppelin.\n\npragma solidity ^0.8.0;\nimport \"./IERC20Metadata.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n * \n * Calls to {transferFrom} do not check for allowance if the caller is the owner\n * of the funds. This allows to reduce the number of approvals that are necessary.\n *\n * Finally, {transferFrom} does not decrease the allowance if it is set to\n * type(uint256).max. This reduces the gas costs without any likely impact.\n */\ncontract ERC20 is IERC20Metadata {\n    uint256                                           internal  _totalSupply;\n    mapping (address => uint256)                      internal  _balanceOf;\n    mapping (address => mapping (address => uint256)) internal  _allowance;\n    string                                            public override name = \"???\";\n    string                                            public override symbol = \"???\";\n    uint8                                             public override decimals = 18;\n\n    /**\n     *  @dev Sets the values for {name}, {symbol} and {decimals}.\n     */\n    constructor(string memory name_, string memory symbol_, uint8 decimals_) {\n        name = name_;\n        symbol = symbol_;\n        decimals = decimals_;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() external view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address guy) external view virtual override returns (uint256) {\n        return _balanceOf[guy];\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) external view virtual override returns (uint256) {\n        return _allowance[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     */\n    function approve(address spender, uint wad) external virtual override returns (bool) {\n        return _setAllowance(msg.sender, spender, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - the caller must have a balance of at least `wad`.\n     */\n    function transfer(address dst, uint wad) external virtual override returns (bool) {\n        return _transfer(msg.sender, dst, wad);\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `wad`.\n     * - the caller is not `src`, it must have allowance for ``src``'s tokens of at least\n     * `wad`.\n     */\n    /// if_succeeds {:msg \"TransferFrom - decrease allowance\"} msg.sender != src ==> old(_allowance[src][msg.sender]) >= wad;\n    function transferFrom(address src, address dst, uint wad) external virtual override returns (bool) {\n        _decreaseAllowance(src, wad);\n\n        return _transfer(src, dst, wad);\n    }\n\n    /**\n     * @dev Moves tokens `wad` from `src` to `dst`.\n     * \n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `src` must have a balance of at least `amount`.\n     */\n    /// if_succeeds {:msg \"Transfer - src decrease\"} old(_balanceOf[src]) >= _balanceOf[src];\n    /// if_succeeds {:msg \"Transfer - dst increase\"} _balanceOf[dst] >= old(_balanceOf[dst]);\n    /// if_succeeds {:msg \"Transfer - supply\"} old(_balanceOf[src]) + old(_balanceOf[dst]) == _balanceOf[src] + _balanceOf[dst];\n    function _transfer(address src, address dst, uint wad) internal virtual returns (bool) {\n        require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n        unchecked { _balanceOf[src] = _balanceOf[src] - wad; }\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n\n        emit Transfer(src, dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Sets the allowance granted to `spender` by `owner`.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     */\n    function _setAllowance(address owner, address spender, uint wad) internal virtual returns (bool) {\n        _allowance[owner][spender] = wad;\n        emit Approval(owner, spender, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Decreases the allowance granted to the caller by `src`, unless src == msg.sender or _allowance[src][msg.sender] == MAX\n     *\n     * Emits an {Approval} event indicating the updated allowance, if the allowance is updated.\n     *\n     * Requirements:\n     *\n     * - `spender` must have allowance for the caller of at least\n     * `wad`, unless src == msg.sender\n     */\n    /// if_succeeds {:msg \"Decrease allowance - underflow\"} old(_allowance[src][msg.sender]) <= _allowance[src][msg.sender];\n    function _decreaseAllowance(address src, uint wad) internal virtual returns (bool) {\n        if (src != msg.sender) {\n            uint256 allowed = _allowance[src][msg.sender];\n            if (allowed != type(uint).max) {\n                require(allowed >= wad, \"ERC20: Insufficient approval\");\n                unchecked { _setAllowance(src, msg.sender, allowed - wad); }\n            }\n        }\n\n        return true;\n    }\n\n    /** @dev Creates `wad` tokens and assigns them to `dst`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     */\n    /// if_succeeds {:msg \"Mint - balance overflow\"} old(_balanceOf[dst]) >= _balanceOf[dst];\n    /// if_succeeds {:msg \"Mint - supply overflow\"} old(_totalSupply) >= _totalSupply;\n    function _mint(address dst, uint wad) internal virtual returns (bool) {\n        _balanceOf[dst] = _balanceOf[dst] + wad;\n        _totalSupply = _totalSupply + wad;\n        emit Transfer(address(0), dst, wad);\n\n        return true;\n    }\n\n    /**\n     * @dev Destroys `wad` tokens from `src`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `src` must have at least `wad` tokens.\n     */\n    /// if_succeeds {:msg \"Burn - balance underflow\"} old(_balanceOf[src]) <= _balanceOf[src];\n    /// if_succeeds {:msg \"Burn - supply underflow\"} old(_totalSupply) <= _totalSupply;\n    function _burn(address src, uint wad) internal virtual returns (bool) {\n        unchecked {\n            require(_balanceOf[src] >= wad, \"ERC20: Insufficient balance\");\n            _balanceOf[src] = _balanceOf[src] - wad;\n            _totalSupply = _totalSupply - wad;\n            emit Transfer(src, address(0), wad);\n        }\n\n        return true;\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/token/IERC2612.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Code adapted from https://github.com/OpenZeppelin/openzeppelin-contracts/pull/2237/\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC2612 standard as defined in the EIP.\n *\n * Adds the {permit} method, which can be used to change one's\n * {IERC20-allowance} without having to send a transaction, by signing a\n * message. This allows users to spend tokens without having to hold Ether.\n *\n * See https://eips.ethereum.org/EIPS/eip-2612.\n */\ninterface IERC2612 {\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over `owner`'s tokens,\n     * given `owner`'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(address owner, address spender, uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s) external;\n\n    /**\n     * @dev Returns the current ERC2612 nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/utils/AddressStringUtil.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity >=0.5.0;\n\nlibrary AddressStringUtil {\n    // converts an address to the uppercase hex string, extracting only len bytes (up to 20, multiple of 2)\n    function toAsciiString(address addr, uint256 len) internal pure returns (string memory) {\n        require(len % 2 == 0 && len > 0 && len <= 40, \"AddressStringUtil: INVALID_LEN\");\n        bytes memory s = new bytes(len);\n        uint256 addrNum = uint256(uint160(addr));\n        for (uint256 ii = 0; ii < len ; ii +=2) {\n            uint8 b = uint8(addrNum >> (4 * (38 - ii)));\n            s[ii] = char(b >> 4);\n            s[ii + 1] = char(b & 0x0f);\n        }\n        return string(s);\n    }\n\n    // hi and lo are only 4 bits and between 0 and 16\n    // this method converts those values to the unicode/ascii code point for the hex representation\n    // uses upper case for the characters\n    function char(uint8 b) private pure returns (bytes1 c) {\n        if (b < 10) {\n            return bytes1(b + 0x30);\n        } else {\n            return bytes1(b + 0x37);\n        }\n    }\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/utils/RevertMsgExtractor.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/sushiswap/BoringSolidity/blob/441e51c0544cf2451e6116fe00515e71d7c42e2c/contracts/BoringBatchable.sol\n\npragma solidity >=0.6.0;\n\n\nlibrary RevertMsgExtractor {\n    /// @dev Helper function to extract a useful revert message from a failed call.\n    /// If the returned data is malformed or not correctly abi encoded then this call can fail itself.\n    function getRevertMsg(bytes memory returnData)\n        internal pure\n        returns (string memory)\n    {\n        // If the _res length is less than 68, then the transaction failed silently (without a revert message)\n        if (returnData.length < 68) return \"Transaction reverted silently\";\n\n        assembly {\n            // Slice the sighash.\n            returnData := add(returnData, 0x04)\n        }\n        return abi.decode(returnData, (string)); // All that remains is the revert string\n    }\n}"
    },
    "contracts/space/PoolFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/utils/IsContract.sol\";\nimport \"@yield-protocol/yieldspace-interfaces/IPoolFactory.sol\";\nimport \"./Pool.sol\";\n\n/// @dev The PoolFactory can deterministically create new pool instances.\ncontract PoolFactory is IPoolFactory, AccessControl {\n    event ParameterSet(bytes32 parameter, int128 value);\n\n    /// Pre-hashing the bytecode allows calculatePoolAddress to be cheaper, and\n    /// makes client-side address calculation easier\n    bytes32 public constant override POOL_BYTECODE_HASH =\n        keccak256(type(Pool).creationCode);\n\n    address public override nextBase;\n    address public override nextFYToken;\n    int128 public override ts = int128(uint128(uint256((1 << 64))) / 315576000); // 1 / Seconds in 10 years, in 64.64\n    int128 public override g1 = int128(uint128(uint256((950 << 64))) / 1000); // To be used when selling base to the pool. All constants are `ufixed`, to divide them they must be converted to uint256\n    int128 public override g2 = int128(uint128(uint256((1000 << 64))) / 950); // To be used when selling fyToken to the pool. All constants are `ufixed`, to divide them they must be converted to uint256\n\n    /// @dev Calculate the deterministic addreess of a pool, based on the base token & fy token.\n    /// @param base Address of the base token (such as Base).\n    /// @param fyToken Address of the fixed yield token (such as fyToken).\n    /// @return The calculated pool address.\n    function calculatePoolAddress(address base, address fyToken)\n        external\n        view\n        override\n        returns (address)\n    {\n        return _calculatePoolAddress(base, fyToken);\n    }\n\n    /// @dev Create2 calculation\n    function _calculatePoolAddress(address base, address fyToken)\n        private\n        view\n        returns (address calculatedAddress)\n    {\n        calculatedAddress = address(\n            uint160(\n                uint256(\n                    keccak256(\n                        abi.encodePacked(\n                            bytes1(0xff),\n                            address(this),\n                            keccak256(abi.encodePacked(base, fyToken)),\n                            POOL_BYTECODE_HASH\n                        )\n                    )\n                )\n            )\n        );\n    }\n\n    /// @dev Calculate the addreess of a pool, and return address(0) if not deployed.\n    /// @param base Address of the base token (such as Base).\n    /// @param fyToken Address of the fixed yield token (such as fyToken).\n    /// @return pool The deployed pool address.\n    function getPool(address base, address fyToken)\n        external\n        view\n        override\n        returns (address pool)\n    {\n        pool = _calculatePoolAddress(base, fyToken);\n\n        if (!IsContract.isContract(pool)) {\n            pool = address(0);\n        }\n    }\n\n    /// @dev Deploys a new pool.\n    /// base & fyToken are written to temporary storage slots to allow for simpler\n    /// address calculation, while still allowing the Pool contract to store the values as\n    /// immutable.\n    /// @param base Address of the base token (such as Base).\n    /// @param fyToken Address of the fixed yield token (such as fyToken).\n    /// @return pool The pool address.\n    function createPool(address base, address fyToken)\n        external\n        override\n        auth\n        returns (address)\n    {\n        nextBase = base;\n        nextFYToken = fyToken;\n        Pool pool = new Pool{\n            salt: keccak256(abi.encodePacked(base, fyToken))\n        }();\n        nextBase = address(0);\n        nextFYToken = address(0);\n\n        emit PoolCreated(base, fyToken, address(pool));\n\n        return address(pool);\n    }\n\n    /// @dev Set the ts, g1 or g2 parameters\n    function setParameter(bytes32 parameter, int128 value) external auth {\n        if (parameter == \"ts\") ts = value;\n        else if (parameter == \"g1\") g1 = value;\n        else if (parameter == \"g2\") g2 = value;\n        else revert(\"Pool: Unrecognized parameter\");\n        emit ParameterSet(parameter, value);\n    }\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/access/AccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\nimport \"hardhat/console.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms.\n *\n * Roles are referred to by their `bytes4` identifier. These are expected to be the \n * signatures for all the functions in the contract. Special roles should be exposed\n * in the external API and be unique:\n *\n * ```\n * bytes4 public constant ROOT = 0x00000000;\n * ```\n *\n * Roles represent restricted access to a function call. For that purpose, use {auth}:\n *\n * ```\n * function foo() public auth {\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `ROOT`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {setRoleAdmin}.\n *\n * WARNING: The `ROOT` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\ncontract AccessControl {\n    struct RoleData {\n        mapping (address => bool) members;\n        bytes4 adminRole;\n    }\n\n    mapping (bytes4 => RoleData) private _roles;\n\n    bytes4 public constant ROOT = 0x00000000;\n    bytes4 public constant ROOT4146650865 = 0x00000000; // Collision protection for ROOT, test with ROOT12007226833()\n    bytes4 public constant LOCK = 0xFFFFFFFF;           // Used to disable further permissioning of a function\n    bytes4 public constant LOCK8605463013 = 0xFFFFFFFF; // Collision protection for LOCK, test with LOCK10462387368()\n\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role\n     *\n     * `ROOT` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes4 indexed role, bytes4 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call.\n     */\n    event RoleGranted(bytes4 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes4 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Give msg.sender the ROOT role and create a LOCK role with itself as the admin role and no members. \n     * Calling setRoleAdmin(msg.sig, LOCK) means no one can grant that msg.sig role anymore.\n     */\n    constructor () {\n        _grantRole(ROOT, msg.sender);   // Grant ROOT to msg.sender\n        _setRoleAdmin(LOCK, LOCK);      // Create the LOCK role by setting itself as its own admin, creating an independent role tree\n    }\n\n    /**\n     * @dev Each function in the contract has its own role, identified by their msg.sig signature.\n     * ROOT can give and remove access to each function, lock any further access being granted to\n     * a specific action, or even create other roles to delegate admin control over a function.\n     */\n    modifier auth() {\n        require (_hasRole(msg.sig, msg.sender), \"Access denied\");\n        _;\n    }\n\n    /**\n     * @dev Allow only if the caller has been granted the admin role of `role`.\n     */\n    modifier admin(bytes4 role) {\n        require (_hasRole(_getRoleAdmin(role), msg.sender), \"Only admin\");\n        _;\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes4 role, address account) external view returns (bool) {\n        return _hasRole(role, account);\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes4 role) external view returns (bytes4) {\n        return _getRoleAdmin(role);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n\n     * If ``role``'s admin role is not `adminRole` emits a {RoleAdminChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function setRoleAdmin(bytes4 role, bytes4 adminRole) external virtual admin(role) {\n        _setRoleAdmin(role, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes4 role, address account) external virtual admin(role) {\n        _grantRole(role, account);\n    }\n\n    \n    /**\n     * @dev Grants all of `role` in `roles` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\n     */\n    function grantRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _grantRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Sets LOCK as ``role``'s admin role. LOCK has no members, so this disables admin management of ``role``.\n\n     * Emits a {RoleAdminChanged} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function lockRole(bytes4 role) external virtual admin(role) {\n        _setRoleAdmin(role, LOCK);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes4 role, address account) external virtual admin(role) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes all of `role` in `roles` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - For each `role` in `roles`, the caller must have ``role``'s admin role.\n     */\n    function revokeRoles(bytes4[] memory roles, address account) external virtual {\n        for (uint256 i = 0; i < roles.length; i++) {\n            require (_hasRole(_getRoleAdmin(roles[i]), msg.sender), \"Only admin\");\n            _revokeRole(roles[i], account);\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes4 role, address account) external virtual {\n        require(account == msg.sender, \"Renounce only for self\");\n\n        _revokeRole(role, account);\n    }\n\n    function _hasRole(bytes4 role, address account) internal view returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    function _getRoleAdmin(bytes4 role) internal view returns (bytes4) {\n        return _roles[role].adminRole;\n    }\n\n    function _setRoleAdmin(bytes4 role, bytes4 adminRole) internal virtual {\n        if (_getRoleAdmin(role) != adminRole) {\n            _roles[role].adminRole = adminRole;\n            emit RoleAdminChanged(role, adminRole);\n        }\n    }\n\n    function _grantRole(bytes4 role, address account) internal {\n        if (!_hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, msg.sender);\n        }\n    }\n\n    function _revokeRole(bytes4 role, address account) internal {\n        if (_hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, msg.sender);\n        }\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/utils/IsContract.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from Address.sol from OpenZeppelin.\npragma solidity ^0.8.0;\n\n\nlibrary IsContract {\n  /// @dev Returns true if `account` is a contract.\n  function isContract(address account) internal view returns (bool) {\n      // This method relies on extcodesize, which returns 0 for contracts in\n      // construction, since the code is only stored at the end of the\n      // constructor execution.\n      return account.code.length > 0;\n  }\n}\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int)\", p0));\n\t}\n\n\tfunction logUint(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/vault/Wand.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \"@yield-protocol/vault-interfaces/ICauldronGov.sol\";\nimport \"@yield-protocol/vault-interfaces/ILadleGov.sol\";\nimport \"@yield-protocol/vault-interfaces/IMultiOracleGov.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoinFactory.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/IFYTokenFactory.sol\";\nimport \"@yield-protocol/vault-interfaces/IFYToken.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"@yield-protocol/yieldspace-interfaces/IPoolFactory.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"./constants/Constants.sol\";\n\ninterface IWitchGov {\n    function limits(bytes6)\n        external\n        view\n        returns (\n            uint96,\n            uint24,\n            uint8,\n            uint128\n        );\n}\n\n/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient governance features.\ncontract Wand is AccessControl, Constants {\n    event Point(bytes32 indexed param, address value);\n\n    bytes4 public constant JOIN = IJoin.join.selector; // bytes4(keccak256(\"join(address,uint128)\"));\n    bytes4 public constant EXIT = IJoin.exit.selector; // bytes4(keccak256(\"exit(address,uint128)\"));\n    bytes4 public constant MINT = IFYToken.mint.selector; // bytes4(keccak256(\"mint(address,uint256)\"));\n    bytes4 public constant BURN = IFYToken.burn.selector; // bytes4(keccak256(\"burn(address,uint256)\"));\n\n    ICauldronGov public cauldron;\n    ILadleGov public ladle;\n    IWitchGov public witch;\n    IPoolFactory public poolFactory;\n    IJoinFactory public joinFactory;\n    IFYTokenFactory public fyTokenFactory;\n\n    constructor(\n        ICauldronGov cauldron_,\n        ILadleGov ladle_,\n        IWitchGov witch_,\n        IPoolFactory poolFactory_,\n        IJoinFactory joinFactory_,\n        IFYTokenFactory fyTokenFactory_\n    ) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n        witch = witch_;\n        poolFactory = poolFactory_;\n        joinFactory = joinFactory_;\n        fyTokenFactory = fyTokenFactory_;\n    }\n\n    /// @dev Point to a different cauldron, ladle, witch, poolFactory, joinFactory or fyTokenFactory\n    function point(bytes32 param, address value) external auth {\n        if (param == \"cauldron\") cauldron = ICauldronGov(value);\n        else if (param == \"ladle\") ladle = ILadleGov(value);\n        else if (param == \"witch\") witch = IWitchGov(value);\n        else if (param == \"poolFactory\") poolFactory = IPoolFactory(value);\n        else if (param == \"joinFactory\") joinFactory = IJoinFactory(value);\n        else if (param == \"fyTokenFactory\")\n            fyTokenFactory = IFYTokenFactory(value);\n        else revert(\"Unrecognized parameter\");\n        emit Point(param, value);\n    }\n\n    /// @dev Add an existing asset to the protocol, meaning:\n    ///  - Add the asset to the cauldron\n    ///  - Deploy a new Join, and integrate it with the Ladle\n    ///  - If the asset is a base, integrate its rate source\n    ///  - If the asset is a base, integrate a spot source and set a debt ceiling for any provided ilks\n    function addAsset(bytes6 assetId, address asset) external auth {\n        // Add asset to cauldron, deploy new Join, and add it to the ladle\n        require(address(asset) != address(0), \"Asset required\");\n        cauldron.addAsset(assetId, asset);\n        AccessControl join = AccessControl(joinFactory.createJoin(asset)); // We need the access control methods of Join\n        bytes4[] memory sigs = new bytes4[](2);\n        sigs[0] = JOIN;\n        sigs[1] = EXIT;\n        join.grantRoles(sigs, address(ladle));\n        join.grantRole(ROOT, msg.sender);\n        // join.renounceRole(ROOT, address(this));  // Wand requires ongoing rights to set up permissions to joins\n        ladle.addJoin(assetId, address(join));\n    }\n\n    /// @dev Make a base asset out of a generic asset.\n    /// @notice `oracle` must be able to deliver a value for assetId and 'rate'\n    function makeBase(bytes6 assetId, IMultiOracleGov oracle) external auth {\n        require(address(oracle) != address(0), \"Oracle required\");\n\n        cauldron.setLendingOracle(assetId, IOracle(address(oracle)));\n\n        AccessControl baseJoin = AccessControl(address(ladle.joins(assetId)));\n        baseJoin.grantRole(JOIN, address(witch)); // Give the Witch permission to join base\n    }\n\n    /// @dev Make an ilk asset out of a generic asset.\n    /// @notice `oracle` must be able to deliver a value for baseId and ilkId\n    function makeIlk(\n        bytes6 baseId,\n        bytes6 ilkId,\n        IMultiOracleGov oracle,\n        uint32 ratio,\n        uint96 max,\n        uint24 min,\n        uint8 dec\n    ) external auth {\n        require(address(oracle) != address(0), \"Oracle required\");\n        (uint96 line, , , ) = witch.limits(ilkId);\n        require(line > 0, \"Initialize ilk in Witch\");\n        cauldron.setSpotOracle(baseId, ilkId, IOracle(address(oracle)), ratio);\n        cauldron.setDebtLimits(baseId, ilkId, max, min, dec);\n\n        AccessControl ilkJoin = AccessControl(address(ladle.joins(ilkId)));\n        ilkJoin.grantRole(EXIT, address(witch)); // Give the Witch permission to exit ilk\n    }\n\n    /// @dev Add an existing series to the protocol, by deploying a FYToken, and registering it in the cauldron with the approved ilks\n    /// This must be followed by a call to addPool\n    function addSeries(\n        bytes6 seriesId,\n        bytes6 baseId,\n        uint32 maturity,\n        bytes6[] calldata ilkIds,\n        string memory name,\n        string memory symbol\n    ) external auth {\n        address base = cauldron.assets(baseId);\n        require(base != address(0), \"Base not found\");\n\n        IJoin baseJoin = ladle.joins(baseId);\n        require(address(baseJoin) != address(0), \"Join not found\");\n\n        IOracle oracle = cauldron.lendingOracles(baseId); // The lending oracles in the Cauldron are also configured to return chi\n        require(address(oracle) != address(0), \"Chi oracle not found\");\n\n        AccessControl fyToken = AccessControl(\n            fyTokenFactory.createFYToken(\n                baseId,\n                oracle,\n                baseJoin,\n                maturity,\n                name, // Derive from base and maturity, perhaps\n                symbol // Derive from base and maturity, perhaps\n            )\n        );\n\n        // Allow the fyToken to pull from the base join for redemption, and to push to mint with underlying\n        bytes4[] memory sigs = new bytes4[](2);\n        sigs[0] = JOIN;\n        sigs[1] = EXIT;\n        AccessControl(address(baseJoin)).grantRoles(sigs, address(fyToken));\n\n        // Allow the ladle to issue and cancel fyToken\n        sigs = new bytes4[](2);\n        sigs[0] = MINT;\n        sigs[1] = BURN;\n        fyToken.grantRoles(sigs, address(ladle));\n\n        // Pass ownership of the fyToken to msg.sender\n        fyToken.grantRole(ROOT, msg.sender);\n        fyToken.renounceRole(ROOT, address(this));\n\n        // Add fyToken/series to the Cauldron and approve ilks for the series\n        cauldron.addSeries(seriesId, baseId, IFYToken(address(fyToken)));\n        cauldron.addIlks(seriesId, ilkIds);\n\n        // Create the pool for the base and fyToken\n        poolFactory.createPool(base, address(fyToken));\n        address pool = poolFactory.calculatePoolAddress(base, address(fyToken));\n\n        // Register pool in Ladle\n        ladle.addPool(seriesId, address(pool));\n    }\n}\n"
    },
    "@yield-protocol/vault-interfaces/ICauldronGov.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./IFYToken.sol\";\nimport \"./IOracle.sol\";\nimport \"./DataTypes.sol\";\n\n\ninterface ICauldronGov {\n    function assets(bytes6) external view returns (address);\n    function series(bytes6) external view returns (DataTypes.Series memory);\n    function lendingOracles(bytes6) external view returns (IOracle);\n    function addAsset(bytes6, address) external;\n    function addSeries(bytes6, bytes6, IFYToken) external;\n    function addIlks(bytes6, bytes6[] memory) external;\n    function setLendingOracle(bytes6, IOracle) external;\n    function setSpotOracle(bytes6, bytes6, IOracle, uint32) external;\n    function setDebtLimits(bytes6, bytes6, uint96, uint24, uint8) external;\n}"
    },
    "@yield-protocol/vault-interfaces/ILadleGov.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IJoin.sol\";\n\ninterface ILadleGov {\n    function joins(bytes6) external view returns (IJoin);\n    function addJoin(bytes6, address) external;\n    function addPool(bytes6, address) external;\n}"
    },
    "@yield-protocol/vault-interfaces/IMultiOracleGov.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IMultiOracleGov {\n    function setSource(bytes6, bytes6, address) external;\n}\n"
    },
    "@yield-protocol/vault-interfaces/IJoinFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n\ninterface IJoinFactory {\n  event JoinCreated(address indexed asset, address pool);\n\n  function createJoin(address asset) external returns (address);\n}\n"
    },
    "@yield-protocol/vault-interfaces/IJoin.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\n\n\ninterface IJoin {\n    /// @dev asset managed by this contract\n    function asset() external view returns (address);\n\n    /// @dev Add tokens to this contract.\n    function join(address user, uint128 wad) external returns (uint128);\n\n    /// @dev Remove tokens to this contract.\n    function exit(address user, uint128 wad) external returns (uint128);\n}"
    },
    "@yield-protocol/vault-interfaces/IFYTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IOracle.sol\";\nimport \"./IJoin.sol\";\n\ninterface IFYTokenFactory {\n  event FYTokenCreated(address indexed fyToken, address indexed asset, uint32 indexed maturity);\n\n  function createFYToken(\n    bytes6 baseId,\n    IOracle oracle,\n    IJoin baseJoin,\n    uint32 maturity,\n    string memory name,\n    string memory symbol\n  ) external returns (address);\n}\n"
    },
    "@yield-protocol/vault-interfaces/DataTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./IFYToken.sol\";\nimport \"./IOracle.sol\";\n\n\nlibrary DataTypes {\n    struct Series {\n        IFYToken fyToken;                                               // Redeemable token for the series.\n        bytes6  baseId;                                                 // Asset received on redemption.\n        uint32  maturity;                                               // Unix time at which redemption becomes possible.\n        // bytes2 free\n    }\n\n    struct Debt {\n        uint96 max;                                                     // Maximum debt accepted for a given underlying, across all series\n        uint24 min;                                                     // Minimum debt accepted for a given underlying, across all series\n        uint8 dec;                                                      // Multiplying factor (10**dec) for max and min \n        uint128 sum;                                                    // Current debt for a given underlying, across all series\n    }\n\n    struct SpotOracle {\n        IOracle oracle;                                                 // Address for the spot price oracle\n        uint32  ratio;                                                  // Collateralization ratio to multiply the price for\n        // bytes8 free\n    }\n\n    struct Vault {\n        address owner;\n        bytes6  seriesId;                                                // Each vault is related to only one series, which also determines the underlying.\n        bytes6  ilkId;                                                   // Asset accepted as collateral\n    }\n\n    struct Balances {\n        uint128 art;                                                     // Debt amount\n        uint128 ink;                                                     // Collateral amount\n    }\n}"
    },
    "contracts/vault/constants/Constants.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\ncontract Constants {\n    bytes32 CHI = \"CHI\";\n    bytes32 RATE = \"RATE\";\n    bytes6 ETH = \"00\";\n}\n"
    },
    "@yield-protocol/vault-interfaces/IOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IOracle {\n    /**\n     * @notice Doesn't refresh the price, but returns the latest value available without doing any transactional operations:\n     * @return value in wei\n     */\n    function peek(bytes32 base, bytes32 quote, uint256 amount) external view returns (uint256 value, uint256 updateTime);\n\n    /**\n     * @notice Does whatever work or queries will yield the most up-to-date price, and returns it.\n     * @return value in wei\n     */\n    function get(bytes32 base, bytes32 quote, uint256 amount) external returns (uint256 value, uint256 updateTime);\n}\n"
    },
    "contracts/vault/FYToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/ERC20Permit.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/SafeERC20Namer.sol\";\nimport \"@yield-protocol/vault-interfaces/IFYToken.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMul.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WDiv.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U32.sol\";\nimport \"./constants/Constants.sol\";\n\ncontract FYToken is\n    IFYToken,\n    IERC3156FlashLender,\n    AccessControl,\n    ERC20Permit,\n    Constants\n{\n    using WMul for uint256;\n    using WDiv for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event Point(bytes32 indexed param, address value);\n    event SeriesMatured(uint256 chiAtMaturity);\n    event Redeemed(\n        address indexed from,\n        address indexed to,\n        uint256 amount,\n        uint256 redeemed\n    );\n\n    uint256 constant CHI_NOT_SET = type(uint256).max;\n\n    uint256 internal constant MAX_TIME_TO_MATURITY = 126144000; // seconds in four years\n    bytes32 internal constant FLASH_LOAN_RETURN =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n\n    IOracle public oracle; // Oracle for the savings rate.\n    IJoin public join; // Source of redemption funds.\n    address public immutable override underlying;\n    bytes6 public immutable underlyingId; // Needed to access the oracle\n    uint256 public immutable override maturity;\n    uint256 public chiAtMaturity = CHI_NOT_SET; // Spot price (exchange rate) between the base and an interest accruing token at maturity\n\n    constructor(\n        bytes6 underlyingId_,\n        IOracle oracle_, // Underlying vs its interest-bearing version\n        IJoin join_,\n        uint256 maturity_,\n        string memory name,\n        string memory symbol\n    )\n        ERC20Permit(\n            name,\n            symbol,\n            SafeERC20Namer.tokenDecimals(address(IJoin(join_).asset()))\n        )\n    {\n        // The join asset is this fyToken's underlying, from which we inherit the decimals\n        uint256 now_ = block.timestamp;\n        require(\n            maturity_ > now_ &&\n                maturity_ < now_ + MAX_TIME_TO_MATURITY &&\n                maturity_ < type(uint32).max,\n            \"Invalid maturity\"\n        );\n\n        underlyingId = underlyingId_;\n        join = join_;\n        maturity = maturity_;\n        underlying = address(IJoin(join_).asset());\n        oracle = oracle_;\n    }\n\n    modifier afterMaturity() {\n        require(uint32(block.timestamp) >= maturity, \"Only after maturity\");\n        _;\n    }\n\n    modifier beforeMaturity() {\n        require(uint32(block.timestamp) < maturity, \"Only before maturity\");\n        _;\n    }\n\n    /// @dev Point to a different Oracle or Join\n    function point(bytes32 param, address value) external auth {\n        if (param == \"oracle\") oracle = IOracle(value);\n        else if (param == \"join\") join = IJoin(value);\n        else revert(\"Unrecognized parameter\");\n        emit Point(param, value);\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    /// If called more than once, it will revert.\n    function mature() external override afterMaturity {\n        require(chiAtMaturity == CHI_NOT_SET, \"Already matured\");\n        _mature();\n    }\n\n    /// @dev Mature the fyToken by recording the chi.\n    function _mature() private returns (uint256 _chiAtMaturity) {\n        (_chiAtMaturity, ) = oracle.get(underlyingId, CHI, 0); // The value returned is an accumulator, it doesn't need an input amount\n        chiAtMaturity = _chiAtMaturity;\n        emit SeriesMatured(_chiAtMaturity);\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    function accrual() external afterMaturity returns (uint256) {\n        return _accrual();\n    }\n\n    /// @dev Retrieve the chi accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual() private returns (uint256 accrual_) {\n        if (chiAtMaturity == CHI_NOT_SET) {\n            // After maturity, but chi not yet recorded. Let's record it, and accrual is then 1.\n            _mature();\n        } else {\n            (uint256 chi, ) = oracle.get(underlyingId, CHI, 0); // The value returned is an accumulator, it doesn't need an input amount\n            accrual_ = chi.wdiv(chiAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18; // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Burn fyToken after maturity for an amount that increases according to `chi`\n    /// If `amount` is 0, the contract will redeem instead the fyToken balance of this contract. Useful for batches.\n    function redeem(address to, uint256 amount)\n        external\n        override\n        afterMaturity\n        returns (uint256 redeemed)\n    {\n        uint256 amount_ = (amount == 0) ? _balanceOf[address(this)] : amount;\n        _burn(msg.sender, amount_);\n        redeemed = amount_.wmul(_accrual());\n        join.exit(to, redeemed.u128());\n\n        emit Redeemed(msg.sender, to, amount_, redeemed);\n    }\n\n    /// @dev Mint fyToken providing an equal amount of underlying to the protocol\n    function mintWithUnderlying(address to, uint256 amount)\n        external\n        override\n        beforeMaturity\n    {\n        _mint(to, amount);\n        join.join(msg.sender, amount.u128());\n    }\n\n    /// @dev Mint fyTokens.\n    function mint(address to, uint256 amount)\n        external\n        override\n        beforeMaturity\n        auth\n    {\n        _mint(to, amount);\n    }\n\n    /// @dev Burn fyTokens. The user needs to have either transferred the tokens to this contract, or have approved this contract to take them.\n    function burn(address from, uint256 amount) external override auth {\n        _burn(from, amount);\n    }\n\n    /// @dev Burn fyTokens.\n    /// Any tokens locked in this contract will be burned first and subtracted from the amount to burn from the user's wallet.\n    /// This feature allows someone to transfer fyToken to this contract to enable a `burn`, potentially saving the cost of `approve` or `permit`.\n    function _burn(address from, uint256 amount)\n        internal\n        override\n        returns (bool)\n    {\n        // First use any tokens locked in this contract\n        uint256 available = _balanceOf[address(this)];\n        if (available >= amount) {\n            return super._burn(address(this), amount);\n        } else {\n            if (available > 0) super._burn(address(this), available);\n            unchecked {\n                _decreaseAllowance(from, amount - available);\n            }\n            unchecked {\n                return super._burn(from, amount - available);\n            }\n        }\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external\n        view\n        override\n        beforeMaturity\n        returns (uint256)\n    {\n        return token == address(this) ? type(uint256).max - _totalSupply : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be a FYDai.\n     * param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256)\n        external\n        view\n        override\n        beforeMaturity\n        returns (uint256)\n    {\n        require(token == address(this), \"Unsupported currency\");\n        return 0;\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` fyDai to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * Note that if the initiator and the borrower are the same address, no approval is needed for this contract to take the principal + fee from the borrower.\n     * If the borrower transfers the principal + fee to this contract, they will be burnt here instead of pulled from the borrower.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes memory data\n    ) external override beforeMaturity returns (bool) {\n        require(token == address(this), \"Unsupported currency\");\n        _mint(address(receiver), amount);\n        require(\n            receiver.onFlashLoan(msg.sender, token, amount, 0, data) ==\n                FLASH_LOAN_RETURN,\n            \"Non-compliant borrower\"\n        );\n        _burn(address(receiver), amount);\n        return true;\n    }\n}\n"
    },
    "erc3156/contracts/interfaces/IERC3156FlashBorrower.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\n\n\ninterface IERC3156FlashBorrower {\n\n    /**\n     * @dev Receive a flash loan.\n     * @param initiator The initiator of the loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param fee The additional amount of tokens to repay.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     * @return The keccak256 hash of \"ERC3156FlashBorrower.onFlashLoan\"\n     */\n    function onFlashLoan(\n        address initiator,\n        address token,\n        uint256 amount,\n        uint256 fee,\n        bytes calldata data\n    ) external returns (bytes32);\n}\n"
    },
    "erc3156/contracts/interfaces/IERC3156FlashLender.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0 <0.9.0;\nimport \"./IERC3156FlashBorrower.sol\";\n\n\ninterface IERC3156FlashLender {\n\n    /**\n     * @dev The amount of currency available to be lended.\n     * @param token The loan currency.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(\n        address token\n    ) external view returns (uint256);\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(\n        address token,\n        uint256 amount\n    ) external view returns (uint256);\n\n    /**\n     * @dev Initiate a flash loan.\n     * @param receiver The receiver of the tokens in the loan, and the receiver of the callback.\n     * @param token The loan currency.\n     * @param amount The amount of tokens lent.\n     * @param data Arbitrary data structure, intended to contain user-defined parameters.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes calldata data\n    ) external returns (bool);\n}"
    },
    "@yield-protocol/utils-v2/contracts/math/WMul.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary WMul {\n    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol\n    /// @dev Multiply an amount by a fixed point factor with 18 decimals, rounds down.\n    function wmul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y;\n        unchecked { z /= 1e18; }\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/math/WDiv.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary WDiv { // Fixed point arithmetic in 18 decimal units\n    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol\n    /// @dev Divide an amount by a fixed point factor with 18 decimals\n    function wdiv(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = (x * 1e18) / y;\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastU256U32.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastU256U32 {\n    /// @dev Safely cast an uint256 to an u32\n    function u32(uint256 x) internal pure returns (uint32 y) {\n        require (x <= type(uint32).max, \"Cast overflow\");\n        y = uint32(x);\n    }\n}"
    },
    "contracts/vault/FYTokenFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/IFYTokenFactory.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"./FYToken.sol\";\n\n/// @dev The FYTokenFactory creates new FYToken instances.\ncontract FYTokenFactory is IFYTokenFactory, AccessControl {\n    /// @dev Deploys a new fyToken.\n    /// @return fyToken The fyToken address.\n    function createFYToken(\n        bytes6 baseId,\n        IOracle oracle,\n        IJoin baseJoin,\n        uint32 maturity,\n        string calldata name,\n        string calldata symbol\n    ) external override auth returns (address) {\n        FYToken fyToken = new FYToken(\n            baseId,\n            oracle,\n            baseJoin,\n            maturity,\n            name, // Derive from base and maturity, perhaps\n            symbol // Derive from base and maturity, perhaps\n        );\n\n        fyToken.grantRole(ROOT, msg.sender);\n        fyToken.renounceRole(ROOT, address(this));\n\n        emit FYTokenCreated(address(fyToken), baseJoin.asset(), maturity);\n\n        return address(fyToken);\n    }\n}\n"
    },
    "contracts/vault/Witch.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/vault-interfaces/ILadle.sol\";\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMul.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMulUp.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WDiv.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WDivUp.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U32.sol\";\n\ncontract Witch is AccessControl {\n    using WMul for uint256;\n    using WMulUp for uint256;\n    using WDiv for uint256;\n    using WDivUp for uint256;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n\n    event Point(bytes32 indexed param, address value);\n    event IlkSet(\n        bytes6 indexed ilkId,\n        uint32 duration,\n        uint64 initialOffer,\n        uint96 line,\n        uint24 dust,\n        uint8 dec\n    );\n    event Bought(\n        bytes12 indexed vaultId,\n        address indexed buyer,\n        uint256 ink,\n        uint256 art\n    );\n    event Auctioned(bytes12 indexed vaultId, uint256 indexed start);\n\n    struct Auction {\n        address owner;\n        uint32 start;\n    }\n\n    struct Ilk {\n        uint32 duration; // Time that auctions take to go to minimal price and stay there.\n        uint64 initialOffer; // Proportion of collateral that is sold at auction start (1e18 = 100%)\n    }\n\n    struct Limits {\n        uint96 line; // Maximum concurrent auctioned collateral\n        uint24 dust; // Minimum collateral that must be left when buying, unless buying all\n        uint8 dec; // Multiplying factor (10**dec) for line and dust\n        uint128 sum; // Current concurrent auctioned collateral\n    }\n\n    ICauldron public immutable cauldron;\n    ILadle public ladle;\n    mapping(bytes12 => Auction) public auctions;\n    mapping(bytes6 => Ilk) public ilks;\n    mapping(bytes6 => Limits) public limits;\n\n    constructor(ICauldron cauldron_, ILadle ladle_) {\n        cauldron = cauldron_;\n        ladle = ladle_;\n    }\n\n    /// @dev Point to a different ladle\n    function point(bytes32 param, address value) external auth {\n        if (param == \"ladle\") ladle = ILadle(value);\n        else revert(\"Unrecognized parameter\");\n        emit Point(param, value);\n    }\n\n    /// @dev Governance function to set:\n    ///  - the auction duration to calculate liquidation prices\n    ///  - the proportion of the collateral that will be sold at auction start\n    ///  - the maximum collateral that can be auctioned at the same time\n    ///  - the minimum collateral that must be left when buying, unless buying all\n    ///  - The decimals for maximum and minimum\n    function setIlk(\n        bytes6 ilkId,\n        uint32 duration,\n        uint64 initialOffer,\n        uint96 line,\n        uint24 dust,\n        uint8 dec\n    ) external auth {\n        require(initialOffer <= 1e18, \"Only at or under 100%\");\n        ilks[ilkId] = Ilk({duration: duration, initialOffer: initialOffer});\n        limits[ilkId] = Limits({\n            line: line,\n            dust: dust,\n            dec: dec,\n            sum: limits[ilkId].sum // sum is initialized at zero, and doesn't change when changing any ilk parameters\n        });\n        emit IlkSet(ilkId, duration, initialOffer, line, dust, dec);\n    }\n\n    /// @dev Put an undercollateralized vault up for liquidation.\n    function auction(bytes12 vaultId) external {\n        require(auctions[vaultId].start == 0, \"Vault already under auction\");\n        require(cauldron.level(vaultId) < 0, \"Not undercollateralized\");\n\n        DataTypes.Vault memory vault_ = cauldron.vaults(vaultId);\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n        Limits memory limits_ = limits[vault_.ilkId];\n        limits_.sum += balances_.ink;\n        require(\n            limits_.sum <= limits_.line * (10**limits_.dec),\n            \"Collateral limit reached\"\n        );\n\n        limits[vault_.ilkId] = limits_;\n        auctions[vaultId] = Auction({\n            owner: vault_.owner,\n            start: block.timestamp.u32()\n        });\n        cauldron.give(vaultId, address(this));\n        emit Auctioned(vaultId, block.timestamp.u32());\n    }\n\n    /// @dev Pay `base` of the debt in a vault in liquidation, getting at least `min` collateral.\n    /// Use `payAll` to pay all the debt, using `buy` for amounts close to the whole vault might revert.\n    function buy(\n        bytes12 vaultId,\n        uint128 base,\n        uint128 min\n    ) external returns (uint256 ink) {\n        require(auctions[vaultId].start > 0, \"Vault not under auction\");\n        DataTypes.Vault memory vault_ = cauldron.vaults(vaultId);\n        DataTypes.Series memory series_ = cauldron.series(vault_.seriesId);\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n        require(balances_.art > 0, \"Nothing to buy\"); // Cheapest way of failing gracefully if given a non existing vault\n\n        Auction memory auction_ = auctions[vaultId];\n        Ilk memory ilk_ = ilks[vault_.ilkId];\n        Limits memory limits_ = limits[vault_.ilkId];\n\n        uint256 art = cauldron.debtFromBase(vault_.seriesId, base);\n        {\n            uint256 elapsed = uint32(block.timestamp) - auction_.start; // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.\n            uint256 price = inkPrice(\n                balances_,\n                ilk_.initialOffer,\n                ilk_.duration,\n                elapsed\n            );\n            ink = uint256(art).wmul(price); // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n            require(ink >= min, \"Not enough bought\");\n            require(\n                art == balances_.art ||\n                    balances_.ink - ink >= limits_.dust * (10**limits_.dec),\n                \"Leaves dust\"\n            );\n            limits[vault_.ilkId].sum -= ink.u128();\n        }\n\n        cauldron.slurp(vaultId, ink.u128(), art.u128()); // Remove debt and collateral from the vault\n        settle(msg.sender, vault_.ilkId, series_.baseId, ink.u128(), base); // Move the assets\n        if (balances_.art - art == 0) {\n            // If there is no debt left, return the vault with the collateral to the owner\n            cauldron.give(vaultId, auction_.owner);\n            delete auctions[vaultId];\n        }\n\n        emit Bought(vaultId, msg.sender, ink, art);\n    }\n\n    /// @dev Pay all debt from a vault in liquidation, getting at least `min` collateral.\n    function payAll(bytes12 vaultId, uint128 min)\n        external\n        returns (uint256 ink)\n    {\n        require(auctions[vaultId].start > 0, \"Vault not under auction\");\n        DataTypes.Vault memory vault_ = cauldron.vaults(vaultId);\n        DataTypes.Series memory series_ = cauldron.series(vault_.seriesId);\n        DataTypes.Balances memory balances_ = cauldron.balances(vaultId);\n        Auction memory auction_ = auctions[vaultId];\n        Ilk memory ilk_ = ilks[vault_.ilkId];\n\n        require(balances_.art > 0, \"Nothing to buy\"); // Cheapest way of failing gracefully if given a non existing vault\n        {\n            uint256 elapsed = uint32(block.timestamp) - auction_.start; // Auctions will malfunction on the 7th of February 2106, at 06:28:16 GMT, we should replace this contract before then.\n            uint256 price = inkPrice(\n                balances_,\n                ilk_.initialOffer,\n                ilk_.duration,\n                elapsed\n            );\n            ink = uint256(balances_.art).wmul(price); // Calculate collateral to sell. Using divdrup stops rounding from leaving 1 stray wei in vaults.\n            require(ink >= min, \"Not enough bought\");\n            ink = (ink > balances_.ink) ? balances_.ink : ink; // The price is rounded up, so we cap this at all the collateral and no more\n            limits[vault_.ilkId].sum -= ink.u128();\n        }\n\n        cauldron.slurp(vaultId, ink.u128(), balances_.art); // Remove debt and collateral from the vault\n        settle(\n            msg.sender,\n            vault_.ilkId,\n            series_.baseId,\n            ink.u128(),\n            cauldron.debtToBase(vault_.seriesId, balances_.art)\n        ); // Move the assets\n        cauldron.give(vaultId, auction_.owner);\n        delete auctions[vaultId];\n\n        emit Bought(vaultId, msg.sender, ink, balances_.art); // Still the initially read `art` value, not the updated one\n    }\n\n    /// @dev Move base from the buyer to the protocol, and collateral from the protocol to the buyer\n    function settle(\n        address user,\n        bytes6 ilkId,\n        bytes6 baseId,\n        uint128 ink,\n        uint128 art\n    ) private {\n        if (ink != 0) {\n            // Give collateral to the user\n            IJoin ilkJoin = ladle.joins(ilkId);\n            require(ilkJoin != IJoin(address(0)), \"Join not found\");\n            ilkJoin.exit(user, ink);\n        }\n        if (art != 0) {\n            // Take underlying from user\n            IJoin baseJoin = ladle.joins(baseId);\n            require(baseJoin != IJoin(address(0)), \"Join not found\");\n            baseJoin.join(user, art);\n        }\n    }\n\n    /// @dev Price of a collateral unit, in underlying, at the present moment, for a given vault. Rounds up, sometimes twice.\n    ///            ink                     min(auction, elapsed)\n    /// price = (------- * (p + (1 - p) * -----------------------))\n    ///            art                          auction\n    function inkPrice(\n        DataTypes.Balances memory balances,\n        uint256 initialOffer_,\n        uint256 duration_,\n        uint256 elapsed\n    ) private pure returns (uint256 price) {\n        uint256 term1 = uint256(balances.ink).wdivup(balances.art);\n        uint256 dividend2 = duration_ < elapsed ? duration_ : elapsed;\n        uint256 divisor2 = duration_;\n        uint256 term2 = initialOffer_ +\n            (1e18 - initialOffer_).wmulup(dividend2.wdivup(divisor2));\n        price = term1.wmulup(term2);\n    }\n}\n"
    },
    "@yield-protocol/vault-interfaces/ILadle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./IJoin.sol\";\nimport \"./ICauldron.sol\";\n\n\ninterface ILadle {\n    function joins(bytes6) external view returns (IJoin);\n    function cauldron() external view returns (ICauldron);\n    function build(bytes6 seriesId, bytes6 ilkId, uint8 salt) external returns (bytes12 vaultId, DataTypes.Vault memory vault);\n    function destroy(bytes12 vaultId) external;\n    function pour(bytes12 vaultId, address to, int128 ink, int128 art) external;\n    function close(bytes12 vaultId, address to, int128 ink, int128 art) external;\n}\n"
    },
    "@yield-protocol/vault-interfaces/ICauldron.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\nimport \"./IFYToken.sol\";\nimport \"./IOracle.sol\";\nimport \"./DataTypes.sol\";\n\n\ninterface ICauldron {\n\n    /// @dev Variable rate lending oracle for an underlying\n    function lendingOracles(bytes6 baseId) external view returns (IOracle);\n\n    /// @dev An user can own one or more Vaults, with each vault being able to borrow from a single series.\n    function vaults(bytes12 vault) external view returns (DataTypes.Vault memory);\n\n    /// @dev Series available in Cauldron.\n    function series(bytes6 seriesId) external view returns (DataTypes.Series memory);\n\n    /// @dev Assets available in Cauldron.\n    function assets(bytes6 assetsId) external view returns (address);\n\n    /// @dev Each vault records debt and collateral balances_.\n    function balances(bytes12 vault) external view returns (DataTypes.Balances memory);\n\n    /// @dev Max, min and sum of debt per underlying and collateral.\n    function debt(bytes6 baseId, bytes6 ilkId) external view returns (DataTypes.Debt memory);\n\n    // @dev Spot price oracle addresses and collateralization ratios\n    function spotOracles(bytes6 baseId, bytes6 ilkId) external returns (DataTypes.SpotOracle memory);\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and up to 5 collateral types\n    function build(address owner, bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) external returns (DataTypes.Vault memory);\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vault) external;\n\n    /// @dev Change a vault series and/or collateral types.\n    function tweak(bytes12 vaultId, bytes6 seriesId, bytes6 ilkId) external returns (DataTypes.Vault memory);\n\n    /// @dev Give a vault to another user.\n    function give(bytes12 vaultId, address receiver) external returns (DataTypes.Vault memory);\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(bytes12 from, bytes12 to, uint128 ink, uint128 art) external returns (DataTypes.Balances memory, DataTypes.Balances memory);\n\n    /// @dev Manipulate a vault debt and collateral.\n    function pour(bytes12 vaultId, int128 ink, int128 art) external returns (DataTypes.Balances memory);\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(bytes12 vaultId, bytes6 seriesId, int128 art) external returns (DataTypes.Vault memory, DataTypes.Balances memory);\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    function slurp(bytes12 vaultId, uint128 ink, uint128 art) external returns (DataTypes.Balances memory);\n\n    // ==== Helpers ====\n\n    /// @dev Convert a debt amount for a series from base to fyToken terms.\n    /// @notice Think about rounding if using, since we are dividing.\n    function debtFromBase(bytes6 seriesId, uint128 base) external returns (uint128 art);\n\n    /// @dev Convert a debt amount for a series from fyToken to base terms\n    function debtToBase(bytes6 seriesId, uint128 art) external returns (uint128 base);\n\n    // ==== Accounting ====\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId) external;\n    \n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId) external returns (uint256);\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) external returns (int256);\n}"
    },
    "@yield-protocol/utils-v2/contracts/math/WMulUp.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary WMulUp { // Fixed point arithmetic in 18 decimal units\n    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol\n    /// @dev Multiply x and y, with y being fixed point. If both are integers, the result is a fixed point factor. Rounds up.\n    function wmulup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * y + 1e18 - 1;        // Rounds up.  So (again imagining 2 decimal places):\n        unchecked { z /= 1e18; }     // 383 (3.83) * 235 (2.35) -> 90005 (9.0005), + 99 (0.0099) -> 90104, / 100 -> 901 (9.01).\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/math/WDivUp.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary WDivUp { // Fixed point arithmetic in 18 decimal units\n    // Taken from https://github.com/usmfum/USM/blob/master/contracts/WadMath.sol\n    /// @dev Divide x and y, with y being fixed point. If both are integers, the result is a fixed point factor. Rounds up.\n    function wdivup(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        z = x * 1e18 + y;            // 101 (1.01) / 1000 (10) -> (101 * 100 + 1000 - 1) / 1000 -> 11 (0.11 = 0.101 rounded up).\n        unchecked { z -= 1; }       // Can do unchecked subtraction since division in next line will catch y = 0 case anyway\n        z /= y;\n    }\n}"
    },
    "contracts/vault/Cauldron.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \"@yield-protocol/vault-interfaces/IFYToken.sol\";\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMul.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WDiv.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WDivUp.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU128I128.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastI128U128.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U32.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256I256.sol\";\nimport \"./constants/Constants.sol\";\n\nlibrary CauldronMath {\n    /// @dev Add a number (which might be negative) to a positive, and revert if the result is negative.\n    function add(uint128 x, int128 y) internal pure returns (uint128 z) {\n        require(y > 0 || x >= uint128(-y), \"Result below zero\");\n        z = y > 0 ? x + uint128(y) : x - uint128(-y);\n    }\n}\n\ncontract Cauldron is AccessControl, Constants {\n    using CauldronMath for uint128;\n    using WMul for uint256;\n    using WDiv for uint256;\n    using WDivUp for uint256;\n    using CastU128I128 for uint128;\n    using CastI128U128 for int128;\n    using CastU256U128 for uint256;\n    using CastU256U32 for uint256;\n    using CastU256I256 for uint256;\n\n    event AssetAdded(bytes6 indexed assetId, address indexed asset);\n    event SeriesAdded(\n        bytes6 indexed seriesId,\n        bytes6 indexed baseId,\n        address indexed fyToken\n    );\n    event IlkAdded(bytes6 indexed seriesId, bytes6 indexed ilkId);\n    event SpotOracleAdded(\n        bytes6 indexed baseId,\n        bytes6 indexed ilkId,\n        address indexed oracle,\n        uint32 ratio\n    );\n    event RateOracleAdded(bytes6 indexed baseId, address indexed oracle);\n    event DebtLimitsSet(\n        bytes6 indexed baseId,\n        bytes6 indexed ilkId,\n        uint96 max,\n        uint24 min,\n        uint8 dec\n    );\n\n    event VaultBuilt(\n        bytes12 indexed vaultId,\n        address indexed owner,\n        bytes6 indexed seriesId,\n        bytes6 ilkId\n    );\n    event VaultTweaked(\n        bytes12 indexed vaultId,\n        bytes6 indexed seriesId,\n        bytes6 indexed ilkId\n    );\n    event VaultDestroyed(bytes12 indexed vaultId);\n    event VaultGiven(bytes12 indexed vaultId, address indexed receiver);\n\n    event VaultPoured(\n        bytes12 indexed vaultId,\n        bytes6 indexed seriesId,\n        bytes6 indexed ilkId,\n        int128 ink,\n        int128 art\n    );\n    event VaultStirred(\n        bytes12 indexed from,\n        bytes12 indexed to,\n        uint128 ink,\n        uint128 art\n    );\n    event VaultRolled(\n        bytes12 indexed vaultId,\n        bytes6 indexed seriesId,\n        uint128 art\n    );\n\n    event SeriesMatured(bytes6 indexed seriesId, uint256 rateAtMaturity);\n\n    // ==== Configuration data ====\n    mapping(bytes6 => address) public assets; // Underlyings and collaterals available in Cauldron. 12 bytes still free.\n    mapping(bytes6 => DataTypes.Series) public series; // Series available in Cauldron. We can possibly use a bytes6 (3e14 possible series).\n    mapping(bytes6 => mapping(bytes6 => bool)) public ilks; // [seriesId][assetId] Assets that are approved as collateral for a series\n\n    mapping(bytes6 => IOracle) public lendingOracles; // Variable rate lending oracle for an underlying\n    mapping(bytes6 => mapping(bytes6 => DataTypes.SpotOracle))\n        public spotOracles; // [assetId][assetId] Spot price oracles\n\n    // ==== Protocol data ====\n    mapping(bytes6 => mapping(bytes6 => DataTypes.Debt)) public debt; // [baseId][ilkId] Max and sum of debt per underlying and collateral.\n    mapping(bytes6 => uint256) public ratesAtMaturity; // Borrowing rate at maturity for a mature series\n\n    // ==== User data ====\n    mapping(bytes12 => DataTypes.Vault) public vaults; // An user can own one or more Vaults, each one with a bytes12 identifier\n    mapping(bytes12 => DataTypes.Balances) public balances; // Both debt and assets\n\n    // ==== Administration ====\n\n    /// @dev Add a new Asset.\n    function addAsset(bytes6 assetId, address asset) external auth {\n        require(assetId != bytes6(0), \"Asset id is zero\");\n        require(assets[assetId] == address(0), \"Id already used\");\n        assets[assetId] = asset;\n        emit AssetAdded(assetId, address(asset));\n    }\n\n    /// @dev Set the maximum and minimum debt for an underlying and ilk pair. Can be reset.\n    function setDebtLimits(\n        bytes6 baseId,\n        bytes6 ilkId,\n        uint96 max,\n        uint24 min,\n        uint8 dec\n    ) external auth {\n        require(assets[baseId] != address(0), \"Base not found\");\n        require(assets[ilkId] != address(0), \"Ilk not found\");\n        DataTypes.Debt memory debt_ = debt[baseId][ilkId];\n        debt_.max = max;\n        debt_.min = min;\n        debt_.dec = dec;\n        debt[baseId][ilkId] = debt_;\n        emit DebtLimitsSet(baseId, ilkId, max, min, dec);\n    }\n\n    /// @dev Set a rate oracle. Can be reset.\n    function setLendingOracle(bytes6 baseId, IOracle oracle) external auth {\n        require(assets[baseId] != address(0), \"Base not found\");\n        lendingOracles[baseId] = oracle;\n        emit RateOracleAdded(baseId, address(oracle));\n    }\n\n    /// @dev Set a spot oracle and its collateralization ratio. Can be reset.\n    function setSpotOracle(\n        bytes6 baseId,\n        bytes6 ilkId,\n        IOracle oracle,\n        uint32 ratio\n    ) external auth {\n        require(assets[baseId] != address(0), \"Base not found\");\n        require(assets[ilkId] != address(0), \"Ilk not found\");\n        spotOracles[baseId][ilkId] = DataTypes.SpotOracle({\n            oracle: oracle,\n            ratio: ratio // With 6 decimals. 1000000 == 100%\n        }); // Allows to replace an existing oracle.\n        emit SpotOracleAdded(baseId, ilkId, address(oracle), ratio);\n    }\n\n    /// @dev Add a new series\n    function addSeries(\n        bytes6 seriesId,\n        bytes6 baseId,\n        IFYToken fyToken\n    ) external auth {\n        require(seriesId != bytes6(0), \"Series id is zero\");\n        address base = assets[baseId];\n        require(base != address(0), \"Base not found\");\n        require(fyToken != IFYToken(address(0)), \"Series need a fyToken\");\n        require(fyToken.underlying() == base, \"Mismatched series and base\");\n        require(\n            lendingOracles[baseId] != IOracle(address(0)),\n            \"Rate oracle not found\"\n        );\n        require(\n            series[seriesId].fyToken == IFYToken(address(0)),\n            \"Id already used\"\n        );\n        series[seriesId] = DataTypes.Series({\n            fyToken: fyToken,\n            maturity: fyToken.maturity().u32(),\n            baseId: baseId\n        });\n        emit SeriesAdded(seriesId, baseId, address(fyToken));\n    }\n\n    /// @dev Add a new Ilk (approve an asset as collateral for a series).\n    function addIlks(bytes6 seriesId, bytes6[] calldata ilkIds) external auth {\n        DataTypes.Series memory series_ = series[seriesId];\n        require(series_.fyToken != IFYToken(address(0)), \"Series not found\");\n        for (uint256 i; i < ilkIds.length; i++) {\n            require(\n                spotOracles[series_.baseId][ilkIds[i]].oracle !=\n                    IOracle(address(0)),\n                \"Spot oracle not found\"\n            );\n            ilks[seriesId][ilkIds[i]] = true;\n            emit IlkAdded(seriesId, ilkIds[i]);\n        }\n    }\n\n    // ==== Vault management ====\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(\n        address owner,\n        bytes12 vaultId,\n        bytes6 seriesId,\n        bytes6 ilkId\n    ) external auth returns (DataTypes.Vault memory vault) {\n        require(vaultId != bytes12(0), \"Vault id is zero\");\n        require(seriesId != bytes12(0), \"Series id is zero\");\n        require(ilkId != bytes12(0), \"Ilk id is zero\");\n        require(vaults[vaultId].seriesId == bytes6(0), \"Vault already exists\"); // Series can't take bytes6(0) as their id\n        require(ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n        vault = DataTypes.Vault({\n            owner: owner,\n            seriesId: seriesId,\n            ilkId: ilkId\n        });\n        vaults[vaultId] = vault;\n\n        emit VaultBuilt(vaultId, owner, seriesId, ilkId);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId) external auth {\n        require(vaults[vaultId].seriesId != bytes6(0), \"Vault doesn't exist\"); // Series can't take bytes6(0) as their id\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        require(balances_.art == 0 && balances_.ink == 0, \"Only empty vaults\");\n        delete vaults[vaultId];\n        emit VaultDestroyed(vaultId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function _tweak(\n        bytes12 vaultId,\n        bytes6 seriesId,\n        bytes6 ilkId\n    ) internal returns (DataTypes.Vault memory vault) {\n        require(seriesId != bytes6(0), \"Series id is zero\");\n        require(ilkId != bytes6(0), \"Ilk id is zero\");\n        require(ilks[seriesId][ilkId] == true, \"Ilk not added to series\");\n\n        vault = vaults[vaultId];\n        require(vault.seriesId != bytes6(0), \"Vault doesn't exist\"); // Series can't take bytes6(0) as their id\n\n        DataTypes.Balances memory balances_ = balances[vaultId];\n        if (seriesId != vault.seriesId) {\n            require(balances_.art == 0, \"Only with no debt\");\n            vault.seriesId = seriesId;\n        }\n        if (ilkId != vault.ilkId) {\n            require(balances_.ink == 0, \"Only with no collateral\");\n            vault.ilkId = ilkId;\n        }\n\n        vaults[vaultId] = vault;\n        emit VaultTweaked(vaultId, vault.seriesId, vault.ilkId);\n    }\n\n    /// @dev Change a vault series and/or collateral types.\n    /// We can change the series if there is no debt, or assets if there are no assets\n    function tweak(\n        bytes12 vaultId,\n        bytes6 seriesId,\n        bytes6 ilkId\n    ) external auth returns (DataTypes.Vault memory vault) {\n        vault = _tweak(vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function _give(bytes12 vaultId, address receiver)\n        internal\n        returns (DataTypes.Vault memory vault)\n    {\n        require(vaultId != bytes12(0), \"Vault id is zero\");\n        require(vaults[vaultId].seriesId != bytes6(0), \"Vault doesn't exist\"); // Series can't take bytes6(0) as their id\n        vault = vaults[vaultId];\n        vault.owner = receiver;\n        vaults[vaultId] = vault;\n        emit VaultGiven(vaultId, receiver);\n    }\n\n    /// @dev Transfer a vault to another user.\n    function give(bytes12 vaultId, address receiver)\n        external\n        auth\n        returns (DataTypes.Vault memory vault)\n    {\n        vault = _give(vaultId, receiver);\n    }\n\n    // ==== Asset and debt management ====\n\n    function vaultData(bytes12 vaultId, bool getSeries)\n        internal\n        view\n        returns (\n            DataTypes.Vault memory vault_,\n            DataTypes.Series memory series_,\n            DataTypes.Balances memory balances_\n        )\n    {\n        vault_ = vaults[vaultId];\n        require(vault_.seriesId != bytes6(0), \"Vault not found\");\n        if (getSeries) series_ = series[vault_.seriesId];\n        balances_ = balances[vaultId];\n    }\n\n    /// @dev Convert a debt amount for a series from base to fyToken terms.\n    /// @notice Think about rounding up if using, since we are dividing.\n    function debtFromBase(bytes6 seriesId, uint128 base)\n        external\n        returns (uint128 art)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            art = uint256(base).wdivup(_accrual(seriesId, series_)).u128();\n        } else {\n            art = base;\n        }\n    }\n\n    /// @dev Convert a debt amount for a series from fyToken to base terms\n    function debtToBase(bytes6 seriesId, uint128 art)\n        external\n        returns (uint128 base)\n    {\n        if (uint32(block.timestamp) >= series[seriesId].maturity) {\n            DataTypes.Series memory series_ = series[seriesId];\n            base = uint256(art).wmul(_accrual(seriesId, series_)).u128();\n        } else {\n            base = art;\n        }\n    }\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(\n        bytes12 from,\n        bytes12 to,\n        uint128 ink,\n        uint128 art\n    )\n        external\n        auth\n        returns (DataTypes.Balances memory, DataTypes.Balances memory)\n    {\n        require(from != to, \"Identical vaults\");\n        (\n            DataTypes.Vault memory vaultFrom,\n            ,\n            DataTypes.Balances memory balancesFrom\n        ) = vaultData(from, false);\n        (\n            DataTypes.Vault memory vaultTo,\n            ,\n            DataTypes.Balances memory balancesTo\n        ) = vaultData(to, false);\n\n        if (ink > 0) {\n            require(vaultFrom.ilkId == vaultTo.ilkId, \"Different collateral\");\n            balancesFrom.ink -= ink;\n            balancesTo.ink += ink;\n        }\n        if (art > 0) {\n            require(vaultFrom.seriesId == vaultTo.seriesId, \"Different series\");\n            balancesFrom.art -= art;\n            balancesTo.art += art;\n        }\n\n        balances[from] = balancesFrom;\n        balances[to] = balancesTo;\n\n        if (ink > 0)\n            require(\n                _level(vaultFrom, balancesFrom, series[vaultFrom.seriesId]) >=\n                    0,\n                \"Undercollateralized at origin\"\n            );\n        if (art > 0)\n            require(\n                _level(vaultTo, balancesTo, series[vaultTo.seriesId]) >= 0,\n                \"Undercollateralized at destination\"\n            );\n\n        emit VaultStirred(from, to, ink, art);\n        return (balancesFrom, balancesTo);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_,\n        int128 ink,\n        int128 art\n    ) internal returns (DataTypes.Balances memory) {\n        // For now, the collateralization checks are done outside to allow for underwater operation. That might change.\n        if (ink != 0) {\n            balances_.ink = balances_.ink.add(ink);\n        }\n\n        // Modify vault and global debt records. If debt increases, check global limit.\n        if (art != 0) {\n            DataTypes.Debt memory debt_ = debt[series_.baseId][vault_.ilkId];\n            balances_.art = balances_.art.add(art);\n            debt_.sum = debt_.sum.add(art);\n            uint128 dust = debt_.min * uint128(10)**debt_.dec;\n            uint128 line = debt_.max * uint128(10)**debt_.dec;\n            require(\n                balances_.art == 0 || balances_.art >= dust,\n                \"Min debt not reached\"\n            );\n            if (art > 0) require(debt_.sum <= line, \"Max debt exceeded\");\n            debt[series_.baseId][vault_.ilkId] = debt_;\n        }\n        balances[vaultId] = balances_;\n\n        emit VaultPoured(vaultId, vault_.seriesId, vault_.ilkId, ink, art);\n        return balances_;\n    }\n\n    /// @dev Manipulate a vault, ensuring it is collateralized afterwards.\n    /// To be used by debt management contracts.\n    function pour(\n        bytes12 vaultId,\n        int128 ink,\n        int128 art\n    ) external auth returns (DataTypes.Balances memory) {\n        (\n            DataTypes.Vault memory vault_,\n            DataTypes.Series memory series_,\n            DataTypes.Balances memory balances_\n        ) = vaultData(vaultId, true);\n\n        balances_ = _pour(vaultId, vault_, balances_, series_, ink, art);\n\n        if (balances_.art > 0 && (ink < 0 || art > 0))\n            // If there is debt and we are less safe\n            require(\n                _level(vault_, balances_, series_) >= 0,\n                \"Undercollateralized\"\n            );\n        return balances_;\n    }\n\n    /// @dev Reduce debt and collateral from a vault, ignoring collateralization checks.\n    /// To be used by liquidation engines.\n    function slurp(\n        bytes12 vaultId,\n        uint128 ink,\n        uint128 art\n    ) external auth returns (DataTypes.Balances memory) {\n        (\n            DataTypes.Vault memory vault_,\n            DataTypes.Series memory series_,\n            DataTypes.Balances memory balances_\n        ) = vaultData(vaultId, true);\n\n        balances_ = _pour(\n            vaultId,\n            vault_,\n            balances_,\n            series_,\n            -(ink.i128()),\n            -(art.i128())\n        );\n\n        return balances_;\n    }\n\n    /// @dev Change series and debt of a vault.\n    /// The module calling this function also needs to buy underlying in the pool for the new series, and sell it in pool for the old series.\n    function roll(\n        bytes12 vaultId,\n        bytes6 newSeriesId,\n        int128 art\n    )\n        external\n        auth\n        returns (DataTypes.Vault memory, DataTypes.Balances memory)\n    {\n        (\n            DataTypes.Vault memory vault_,\n            DataTypes.Series memory oldSeries_,\n            DataTypes.Balances memory balances_\n        ) = vaultData(vaultId, true);\n        DataTypes.Series memory newSeries_ = series[newSeriesId];\n        require(\n            oldSeries_.baseId == newSeries_.baseId,\n            \"Mismatched bases in series\"\n        );\n\n        // Set the vault art to zero\n        int128 oldArt = balances_.art.i128();\n        balances_ = _pour(vaultId, vault_, balances_, oldSeries_, 0, -oldArt);\n\n        // Change the vault series\n        _tweak(vaultId, newSeriesId, vault_.ilkId);\n\n        // Set the vault art to it's newSeries value by adding `art` to that from the old series\n        balances_ = _pour(\n            vaultId,\n            vault_,\n            balances_,\n            newSeries_,\n            0,\n            oldArt + art\n        );\n\n        require(\n            _level(vault_, balances_, newSeries_) >= 0,\n            \"Undercollateralized\"\n        );\n        emit VaultRolled(vaultId, newSeriesId, balances_.art);\n\n        return (vault_, balances_);\n    }\n\n    // ==== Accounting ====\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function level(bytes12 vaultId) external returns (int256) {\n        (\n            DataTypes.Vault memory vault_,\n            DataTypes.Series memory series_,\n            DataTypes.Balances memory balances_\n        ) = vaultData(vaultId, true);\n\n        return _level(vault_, balances_, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function mature(bytes6 seriesId) external {\n        require(ratesAtMaturity[seriesId] == 0, \"Already matured\");\n        DataTypes.Series memory series_ = series[seriesId];\n        _mature(seriesId, series_);\n    }\n\n    /// @dev Record the borrowing rate at maturity for a series\n    function _mature(bytes6 seriesId, DataTypes.Series memory series_)\n        internal\n    {\n        require(\n            uint32(block.timestamp) >= series_.maturity,\n            \"Only after maturity\"\n        );\n        IOracle rateOracle = lendingOracles[series_.baseId];\n        (uint256 rateAtMaturity, ) = rateOracle.get(series_.baseId, RATE, 0); // The value returned is an accumulator, it doesn't need an input amount\n        ratesAtMaturity[seriesId] = rateAtMaturity;\n        emit SeriesMatured(seriesId, rateAtMaturity);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    function accrual(bytes6 seriesId) external returns (uint256) {\n        DataTypes.Series memory series_ = series[seriesId];\n        return _accrual(seriesId, series_);\n    }\n\n    /// @dev Retrieve the rate accrual since maturity, maturing if necessary.\n    /// Note: Call only after checking we are past maturity\n    function _accrual(bytes6 seriesId, DataTypes.Series memory series_)\n        private\n        returns (uint256 accrual_)\n    {\n        uint256 rateAtMaturity = ratesAtMaturity[seriesId];\n        if (rateAtMaturity == 0) {\n            // After maturity, but rate not yet recorded. Let's record it, and accrual is then 1.\n            _mature(seriesId, series_);\n        } else {\n            IOracle rateOracle = lendingOracles[series_.baseId];\n            (uint256 rate, ) = rateOracle.get(series_.baseId, RATE, 0); // The value returned is an accumulator, it doesn't need an input amount\n            accrual_ = rate.wdiv(rateAtMaturity);\n        }\n        accrual_ = accrual_ >= 1e18 ? accrual_ : 1e18; // The accrual can't be below 1 (with 18 decimals)\n    }\n\n    /// @dev Return the collateralization level of a vault. It will be negative if undercollateralized.\n    function _level(\n        DataTypes.Vault memory vault_,\n        DataTypes.Balances memory balances_,\n        DataTypes.Series memory series_\n    ) internal returns (int256) {\n        DataTypes.SpotOracle memory spotOracle_ = spotOracles[series_.baseId][\n            vault_.ilkId\n        ];\n        uint256 ratio = uint256(spotOracle_.ratio) * 1e12; // Normalized to 18 decimals\n        (uint256 inkValue, ) = spotOracle_.oracle.get(\n            vault_.ilkId,\n            series_.baseId,\n            balances_.ink\n        ); // ink * spot\n\n        if (uint32(block.timestamp) >= series_.maturity) {\n            uint256 accrual_ = _accrual(vault_.seriesId, series_);\n            return\n                inkValue.i256() -\n                uint256(balances_.art).wmul(accrual_).wmul(ratio).i256();\n        }\n\n        return inkValue.i256() - uint256(balances_.art).wmul(ratio).i256();\n    }\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastI128U128.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastI128U128 {\n    /// @dev Safely cast an int128 to an uint128\n    function u128(int128 x) internal pure returns (uint128 y) {\n        require (x >= 0, \"Cast overflow\");\n        y = uint128(x);\n    }\n}"
    },
    "contracts/vault/Ladle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \"@yield-protocol/vault-interfaces/IFYToken.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"@yield-protocol/vault-interfaces/DataTypes.sol\";\nimport \"@yield-protocol/yieldspace-interfaces/IPool.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC2612.sol\";\nimport \"dss-interfaces/src/dss/DaiAbstract.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMul.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256I128.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU128I128.sol\";\nimport \"./LadleStorage.sol\";\n\n/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient user oriented features.\ncontract Ladle is LadleStorage, AccessControl {\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n    using CastU256I128 for uint256;\n    using CastU128I128 for uint128;\n    using TransferHelper for IERC20;\n    using TransferHelper for address payable;\n\n    constructor(ICauldron cauldron, IWETH9 weth) LadleStorage(cauldron, weth) {}\n\n    // ---- Data sourcing ----\n    /// @dev Obtains a vault by vaultId from the Cauldron, and verifies that msg.sender is the owner\n    /// If bytes(0) is passed as the vaultId it tries to load a vault from the cache\n    function getVault(bytes12 vaultId_)\n        internal\n        view\n        returns (bytes12 vaultId, DataTypes.Vault memory vault)\n    {\n        if (vaultId_ == bytes12(0)) {\n            // We use the cache\n            require(cachedVaultId != bytes12(0), \"Vault not cached\");\n            vaultId = cachedVaultId;\n        } else {\n            vaultId = vaultId_;\n        }\n        vault = cauldron.vaults(vaultId);\n        require(vault.owner == msg.sender, \"Only vault owner\");\n    }\n\n    /// @dev Obtains a series by seriesId from the Cauldron, and verifies that it exists\n    function getSeries(bytes6 seriesId)\n        internal\n        view\n        returns (DataTypes.Series memory series)\n    {\n        series = cauldron.series(seriesId);\n        require(series.fyToken != IFYToken(address(0)), \"Series not found\");\n    }\n\n    /// @dev Obtains a join by assetId, and verifies that it exists\n    function getJoin(bytes6 assetId) internal view returns (IJoin join) {\n        join = joins[assetId];\n        require(join != IJoin(address(0)), \"Join not found\");\n    }\n\n    /// @dev Obtains a pool by seriesId, and verifies that it exists\n    function getPool(bytes6 seriesId) internal view returns (IPool pool) {\n        pool = pools[seriesId];\n        require(pool != IPool(address(0)), \"Pool not found\");\n    }\n\n    // ---- Administration ----\n\n    /// @dev Add or remove an integration.\n    function addIntegration(address integration, bool set) external auth {\n        _addIntegration(integration, set);\n    }\n\n    /// @dev Add or remove an integration.\n    function _addIntegration(address integration, bool set) private {\n        integrations[integration] = set;\n        emit IntegrationAdded(integration, set);\n    }\n\n    /// @dev Add or remove a token that the Ladle can call `transfer` or `permit` on.\n    function addToken(address token, bool set) external auth {\n        _addToken(token, set);\n    }\n\n    /// @dev Add or remove a token that the Ladle can call `transfer` or `permit` on.\n    function _addToken(address token, bool set) private {\n        tokens[token] = set;\n        emit TokenAdded(token, set);\n    }\n\n    /// @dev Add a new Join for an Asset, or replace an existing one for a new one.\n    /// There can be only one Join per Asset. Until a Join is added, no tokens of that Asset can be posted or withdrawn.\n    function addJoin(bytes6 assetId, IJoin join) external auth {\n        address asset = cauldron.assets(assetId);\n        require(asset != address(0), \"Asset not found\");\n        require(join.asset() == asset, \"Mismatched asset and join\");\n        joins[assetId] = join;\n\n        bool set = (join != IJoin(address(0))) ? true : false;\n        _addToken(asset, set); // address(0) disables the token\n        emit JoinAdded(assetId, address(join));\n    }\n\n    /// @dev Add a new Pool for a Series, or replace an existing one for a new one.\n    /// There can be only one Pool per Series. Until a Pool is added, it is not possible to borrow Base.\n    function addPool(bytes6 seriesId, IPool pool) external auth {\n        IFYToken fyToken = getSeries(seriesId).fyToken;\n        require(\n            fyToken == pool.fyToken(),\n            \"Mismatched pool fyToken and series\"\n        );\n        require(\n            fyToken.underlying() == address(pool.base()),\n            \"Mismatched pool base and series\"\n        );\n        pools[seriesId] = pool;\n\n        bool set = (pool != IPool(address(0))) ? true : false;\n        _addToken(address(fyToken), set); // address(0) disables the token\n        _addToken(address(pool), set); // address(0) disables the token\n        _addIntegration(address(pool), set); // address(0) disables the integration\n\n        emit PoolAdded(seriesId, address(pool));\n    }\n\n    /// @dev Add or remove a module.\n    /// @notice Treat modules as you would Ladle upgrades. Modules have unrestricted access to the Ladle\n    /// storage, and can wreak havoc easily.\n    /// Modules must not do any changes to any vault (owner, seriesId, ilkId) because of vault caching.\n    /// Modules must not be contracts that can self-destruct because of `moduleCall`.\n    /// Modules can't use `msg.value` because of `batch`.\n    function addModule(address module, bool set) external auth {\n        modules[module] = set;\n        emit ModuleAdded(module, set);\n    }\n\n    /// @dev Set the fee parameter\n    function setFee(uint256 fee) external auth {\n        borrowingFee = fee;\n        emit FeeSet(fee);\n    }\n\n    // ---- Call management ----\n\n    /// @dev Allows batched call to self (this contract).\n    /// @param calls An array of inputs for each call.\n    function batch(bytes[] calldata calls)\n        external\n        payable\n        returns (bytes[] memory results)\n    {\n        results = new bytes[](calls.length);\n        for (uint256 i; i < calls.length; i++) {\n            (bool success, bytes memory result) = address(this).delegatecall(\n                calls[i]\n            );\n            if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n            results[i] = result;\n        }\n\n        // build would have populated the cache, this deletes it\n        cachedVaultId = bytes12(0);\n    }\n\n    /// @dev Allow users to route calls to a contract, to be used with batch\n    function route(address integration, bytes calldata data)\n        external\n        payable\n        returns (bytes memory result)\n    {\n        require(integrations[integration], \"Unknown integration\");\n        return router.route(integration, data);\n    }\n\n    /// @dev Allow users to use functionality coded in a module, to be used with batch\n    function moduleCall(address module, bytes calldata data)\n        external\n        payable\n        returns (bytes memory result)\n    {\n        require(modules[module], \"Unregistered module\");\n        bool success;\n        (success, result) = module.delegatecall(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n\n    // ---- Token management ----\n\n    /// @dev Execute an ERC2612 permit for the selected token\n    function forwardPermit(\n        IERC2612 token,\n        address spender,\n        uint256 amount,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        require(tokens[address(token)], \"Unknown token\");\n        token.permit(msg.sender, spender, amount, deadline, v, r, s);\n    }\n\n    /// @dev Execute a Dai-style permit for the selected token\n    function forwardDaiPermit(\n        DaiAbstract token,\n        address spender,\n        uint256 nonce,\n        uint256 deadline,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable {\n        require(tokens[address(token)], \"Unknown token\");\n        token.permit(msg.sender, spender, nonce, deadline, allowed, v, r, s);\n    }\n\n    /// @dev Allow users to trigger a token transfer from themselves to a receiver through the ladle, to be used with batch\n    function transfer(\n        IERC20 token,\n        address receiver,\n        uint128 wad\n    ) external payable {\n        require(tokens[address(token)], \"Unknown token\");\n        token.safeTransferFrom(msg.sender, receiver, wad);\n    }\n\n    /// @dev Retrieve any token in the Ladle\n    function retrieve(IERC20 token, address to)\n        external\n        payable\n        returns (uint256 amount)\n    {\n        require(tokens[address(token)], \"Unknown token\");\n        amount = token.balanceOf(address(this));\n        token.safeTransfer(to, amount);\n    }\n\n    /// @dev The WETH9 contract will send ether to BorrowProxy on `weth.withdraw` using this function.\n    receive() external payable {\n        require(msg.sender == address(weth), \"Only receive from WETH\");\n    }\n\n    /// @dev Accept Ether, wrap it and forward it to the WethJoin\n    /// This function should be called first in a batch, and the Join should keep track of stored reserves\n    /// Passing the id for a join that doesn't link to a contract implemnting IWETH9 will fail\n    function joinEther(bytes6 etherId)\n        external\n        payable\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = address(this).balance;\n        IJoin wethJoin = getJoin(etherId);\n        weth.deposit{value: ethTransferred}();\n        IERC20(address(weth)).safeTransfer(address(wethJoin), ethTransferred);\n    }\n\n    /// @dev Unwrap Wrapped Ether held by this Ladle, and send the Ether\n    /// This function should be called last in a batch, and the Ladle should have no reason to keep an WETH balance\n    function exitEther(address payable to)\n        external\n        payable\n        returns (uint256 ethTransferred)\n    {\n        ethTransferred = weth.balanceOf(address(this));\n        weth.withdraw(ethTransferred);\n        to.safeTransferETH(ethTransferred);\n    }\n\n    // ---- Vault management ----\n\n    /// @dev Generate a vaultId. A keccak256 is cheaper than using a counter with a SSTORE, even accounting for eventual collision retries.\n    function _generateVaultId(uint8 salt) private view returns (bytes12) {\n        return\n            bytes12(\n                keccak256(abi.encodePacked(msg.sender, block.timestamp, salt))\n            );\n    }\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function build(\n        bytes6 seriesId,\n        bytes6 ilkId,\n        uint8 salt\n    ) external payable returns (bytes12, DataTypes.Vault memory) {\n        return _build(seriesId, ilkId, salt);\n    }\n\n    /// @dev Create a new vault, linked to a series (and therefore underlying) and a collateral\n    function _build(\n        bytes6 seriesId,\n        bytes6 ilkId,\n        uint8 salt\n    ) private returns (bytes12 vaultId, DataTypes.Vault memory vault) {\n        vaultId = _generateVaultId(salt);\n        while (cauldron.vaults(vaultId).seriesId != bytes6(0))\n            vaultId = _generateVaultId(++salt); // If the vault exists, generate other random vaultId\n        vault = cauldron.build(msg.sender, vaultId, seriesId, ilkId);\n        // Store the vault data in the cache\n        cachedVaultId = vaultId;\n    }\n\n    /// @dev Change a vault series or collateral.\n    function tweak(\n        bytes12 vaultId_,\n        bytes6 seriesId,\n        bytes6 ilkId\n    ) external payable returns (DataTypes.Vault memory vault) {\n        (bytes12 vaultId, ) = getVault(vaultId_); // getVault verifies the ownership as well\n        // tweak checks that the series and the collateral both exist and that the collateral is approved for the series\n        vault = cauldron.tweak(vaultId, seriesId, ilkId);\n    }\n\n    /// @dev Give a vault to another user.\n    function give(bytes12 vaultId_, address receiver)\n        external\n        payable\n        returns (DataTypes.Vault memory vault)\n    {\n        (bytes12 vaultId, ) = getVault(vaultId_);\n        vault = cauldron.give(vaultId, receiver);\n    }\n\n    /// @dev Destroy an empty vault. Used to recover gas costs.\n    function destroy(bytes12 vaultId_) external payable {\n        (bytes12 vaultId, ) = getVault(vaultId_);\n        cauldron.destroy(vaultId);\n    }\n\n    // ---- Asset and debt management ----\n\n    /// @dev Move collateral and debt between vaults.\n    function stir(\n        bytes12 from,\n        bytes12 to,\n        uint128 ink,\n        uint128 art\n    ) external payable {\n        if (ink > 0)\n            require(\n                cauldron.vaults(from).owner == msg.sender,\n                \"Only origin vault owner\"\n            );\n        if (art > 0)\n            require(\n                cauldron.vaults(to).owner == msg.sender,\n                \"Only destination vault owner\"\n            );\n        cauldron.stir(from, to, ink, art);\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    /// Borrow only before maturity.\n    function _pour(\n        bytes12 vaultId,\n        DataTypes.Vault memory vault,\n        address to,\n        int128 ink,\n        int128 art\n    ) private {\n        DataTypes.Series memory series;\n        if (art != 0) series = getSeries(vault.seriesId);\n\n        int128 fee;\n        if (art > 0 && vault.ilkId != series.baseId && borrowingFee != 0)\n            fee = ((series.maturity - block.timestamp) *\n                uint256(int256(art)).wmul(borrowingFee)).i128();\n\n        // Update accounting\n        cauldron.pour(vaultId, ink, art + fee);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage debt tokens\n        if (art != 0) {\n            if (art > 0) series.fyToken.mint(to, uint128(art));\n            else series.fyToken.burn(msg.sender, uint128(-art));\n        }\n    }\n\n    /// @dev Add collateral and borrow from vault, pull assets from and push borrowed asset to user\n    /// Or, repay to vault and remove collateral, pull borrowed asset from and push assets to user\n    /// Borrow only before maturity.\n    function pour(\n        bytes12 vaultId_,\n        address to,\n        int128 ink,\n        int128 art\n    ) external payable {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        _pour(vaultId, vault, to, ink, art);\n    }\n\n    /// @dev Add collateral and borrow from vault, so that a precise amount of base is obtained by the user.\n    /// The base is obtained by borrowing fyToken and buying base with it in a pool.\n    /// Only before maturity.\n    function serve(\n        bytes12 vaultId_,\n        address to,\n        uint128 ink,\n        uint128 base,\n        uint128 max\n    ) external payable returns (uint128 art) {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        IPool pool = getPool(vault.seriesId);\n\n        art = pool.buyBasePreview(base);\n        _pour(vaultId, vault, address(pool), ink.i128(), art.i128());\n        pool.buyBase(to, base, max);\n    }\n\n    /// @dev Repay vault debt using underlying token at a 1:1 exchange rate, without trading in a pool.\n    /// It can add or remove collateral at the same time.\n    /// The debt to repay is denominated in fyToken, even if the tokens pulled from the user are underlying.\n    /// The debt to repay must be entered as a negative number, as with `pour`.\n    /// Debt cannot be acquired with this function.\n    function close(\n        bytes12 vaultId_,\n        address to,\n        int128 ink,\n        int128 art\n    ) external payable returns (uint128 base) {\n        require(art < 0, \"Only repay debt\"); // When repaying debt in `frob`, art is a negative value. Here is the same for consistency.\n\n        // Calculate debt in fyToken terms\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        base = cauldron.debtToBase(vault.seriesId, uint128(-art));\n\n        // Update accounting\n        cauldron.pour(vaultId, ink, art);\n\n        // Manage collateral\n        if (ink != 0) {\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            if (ink > 0) ilkJoin.join(vault.owner, uint128(ink));\n            if (ink < 0) ilkJoin.exit(to, uint128(-ink));\n        }\n\n        // Manage underlying\n        IJoin baseJoin = getJoin(series.baseId);\n        baseJoin.join(msg.sender, base);\n    }\n\n    /// @dev Repay debt by selling base in a pool and using the resulting fyToken\n    /// The base tokens need to be already in the pool, unaccounted for.\n    /// Only before maturity. After maturity use close.\n    function repay(\n        bytes12 vaultId_,\n        address to,\n        int128 ink,\n        uint128 min\n    ) external payable returns (uint128 art) {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        art = pool.sellBase(address(series.fyToken), min);\n        _pour(vaultId, vault, to, ink, -(art.i128()));\n    }\n\n    /// @dev Repay all debt in a vault by buying fyToken from a pool with base.\n    /// The base tokens need to be already in the pool, unaccounted for. The surplus base will be returned to msg.sender.\n    /// Only before maturity. After maturity use close.\n    function repayVault(\n        bytes12 vaultId_,\n        address to,\n        int128 ink,\n        uint128 max\n    ) external payable returns (uint128 base) {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        IPool pool = getPool(vault.seriesId);\n\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        base = pool.buyFYToken(address(series.fyToken), balances.art, max);\n        _pour(vaultId, vault, to, ink, -(balances.art.i128()));\n        pool.retrieveBase(msg.sender);\n    }\n\n    /// @dev Change series and debt of a vault.\n    function roll(\n        bytes12 vaultId_,\n        bytes6 newSeriesId,\n        uint8 loan,\n        uint128 max\n    ) external payable returns (DataTypes.Vault memory vault, uint128 newDebt) {\n        bytes12 vaultId;\n        (vaultId, vault) = getVault(vaultId_);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Series memory newSeries = getSeries(newSeriesId);\n\n        {\n            IPool pool = getPool(newSeriesId);\n            IFYToken fyToken = IFYToken(newSeries.fyToken);\n            IJoin baseJoin = getJoin(series.baseId);\n\n            // Calculate debt in fyToken terms\n            uint128 base = cauldron.debtToBase(vault.seriesId, balances.art);\n\n            // Mint fyToken to the pool, as a kind of flash loan\n            fyToken.mint(address(pool), base * loan); // Loan is the size of the flash loan relative to the debt amount, 2 should be safe most of the time\n\n            // Buy the base required to pay off the debt in series 1, and find out the debt in series 2\n            newDebt = pool.buyBase(address(baseJoin), base, max);\n            baseJoin.join(address(baseJoin), base); // Repay the old series debt\n\n            pool.retrieveFYToken(address(fyToken)); // Get the surplus fyToken\n            fyToken.burn(address(fyToken), (base * loan) - newDebt); // Burn the surplus\n        }\n\n        if (vault.ilkId != newSeries.baseId && borrowingFee != 0)\n            newDebt += ((newSeries.maturity - block.timestamp) *\n                uint256(newDebt).wmul(borrowingFee)).u128(); // Add borrowing fee, also stops users form rolling to a mature series\n\n        (vault, ) = cauldron.roll(\n            vaultId,\n            newSeriesId,\n            newDebt.i128() - balances.art.i128()\n        ); // Change the series and debt for the vault\n\n        return (vault, newDebt);\n    }\n\n    // ---- Ladle as a token holder ----\n\n    /// @dev Use fyToken in the Ladle to repay debt. Return unused fyToken to `to`.\n    /// Return as much collateral as debt was repaid, as well. This function is only used when\n    /// removing liquidity added with \"Borrow and Pool\", so it's safe to assume the exchange rate\n    /// is 1:1. If used in other contexts, it might revert, which is fine.\n    function repayFromLadle(bytes12 vaultId_, address to)\n        external\n        payable\n        returns (uint256 repaid)\n    {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n\n        uint256 amount = series.fyToken.balanceOf(address(this));\n        repaid = amount <= balances.art ? amount : balances.art;\n\n        // Update accounting, burn fyToken and return collateral\n        if (repaid > 0) {\n            cauldron.pour(vaultId, -(repaid.i128()), -(repaid.i128()));\n            series.fyToken.burn(address(this), repaid);\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            ilkJoin.exit(to, repaid.u128());\n        }\n\n        // Return remainder\n        if (amount - repaid > 0)\n            IERC20(address(series.fyToken)).safeTransfer(to, amount - repaid);\n    }\n\n    /// @dev Use base in the Ladle to repay debt. Return unused base to `to`.\n    /// Return as much collateral as debt was repaid, as well. This function is only used when\n    /// removing liquidity added with \"Borrow and Pool\", so it's safe to assume the exchange rate\n    /// is 1:1. If used in other contexts, it might revert, which is fine.\n    function closeFromLadle(bytes12 vaultId_, address to)\n        external\n        payable\n        returns (uint256 repaid)\n    {\n        (bytes12 vaultId, DataTypes.Vault memory vault) = getVault(vaultId_);\n        DataTypes.Series memory series = getSeries(vault.seriesId);\n        DataTypes.Balances memory balances = cauldron.balances(vaultId);\n\n        IERC20 base = IERC20(cauldron.assets(series.baseId));\n        uint256 amount = base.balanceOf(address(this));\n        uint256 debtInBase = cauldron.debtToBase(vault.seriesId, balances.art);\n        uint128 repaidInBase = ((amount <= debtInBase) ? amount : debtInBase)\n            .u128();\n        repaid = (repaidInBase == debtInBase)\n            ? balances.art\n            : cauldron.debtFromBase(vault.seriesId, repaidInBase);\n\n        // Update accounting, join base and return collateral\n        if (repaidInBase > 0) {\n            cauldron.pour(vaultId, -(repaid.i128()), -(repaid.i128()));\n            IJoin baseJoin = getJoin(series.baseId);\n            base.safeTransfer(address(baseJoin), repaidInBase);\n            baseJoin.join(address(this), repaidInBase);\n            IJoin ilkJoin = getJoin(vault.ilkId);\n            ilkJoin.exit(to, repaid.u128()); // repaid is the ink collateral released, and equal to the fyToken debt. repaidInBase is the value of the fyToken debt in base terms\n        }\n\n        // Return remainder\n        if (amount - repaidInBase > 0)\n            base.safeTransfer(to, amount - repaidInBase);\n    }\n\n    /// @dev Allow users to redeem fyToken, to be used with batch.\n    /// If 0 is passed as the amount to redeem, it redeems the fyToken balance of the Ladle instead.\n    function redeem(\n        bytes6 seriesId,\n        address to,\n        uint256 wad\n    ) external payable returns (uint256) {\n        IFYToken fyToken = getSeries(seriesId).fyToken;\n        return\n            fyToken.redeem(\n                to,\n                wad != 0 ? wad : fyToken.balanceOf(address(this))\n            );\n    }\n}\n"
    },
    "dss-interfaces/src/dss/DaiAbstract.sol": {
      "content": "// SPDX-License-Identifier: GPL-3.0-or-later\npragma solidity >=0.5.12;\n\n// https://github.com/makerdao/dss/blob/master/src/dai.sol\ninterface DaiAbstract {\n    function wards(address) external view returns (uint256);\n    function rely(address) external;\n    function deny(address) external;\n    function name() external view returns (string memory);\n    function symbol() external view returns (string memory);\n    function version() external view returns (string memory);\n    function decimals() external view returns (uint8);\n    function totalSupply() external view returns (uint256);\n    function balanceOf(address) external view returns (uint256);\n    function allowance(address, address) external view returns (uint256);\n    function nonces(address) external view returns (uint256);\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n    function PERMIT_TYPEHASH() external view returns (bytes32);\n    function transfer(address, uint256) external;\n    function transferFrom(address, address, uint256) external returns (bool);\n    function mint(address, uint256) external;\n    function burn(address, uint256) external;\n    function approve(address, uint256) external returns (bool);\n    function push(address, uint256) external;\n    function pull(address, uint256) external;\n    function move(address, address, uint256) external;\n    function permit(address, address, uint256, uint256, bool, uint8, bytes32, bytes32) external;\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/token/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// Taken from https://github.com/Uniswap/uniswap-lib/blob/master/contracts/libraries/TransferHelper.sol\n\npragma solidity >=0.6.0;\n\nimport \"./IERC20.sol\";\nimport \"../utils/RevertMsgExtractor.sol\";\n\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    /// @notice Transfers tokens from msg.sender to a recipient\n    /// @dev Errors with the underlying revert message if transfer fails\n    /// @param token The contract address of the token which will be transferred\n    /// @param to The recipient of the transfer\n    /// @param value The value of the transfer\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transfer.selector, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));\n    }\n\n    /// @notice Transfers tokens from the targeted address to the given destination\n    /// @dev Errors with the underlying revert message if transfer fails\n    /// @param token The contract address of the token to be transferred\n    /// @param from The originating address from which the tokens will be transferred\n    /// @param to The destination address of the transfer\n    /// @param value The amount to be transferred\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        (bool success, bytes memory data) = address(token).call(abi.encodeWithSelector(IERC20.transferFrom.selector, from, to, value));\n        if (!(success && (data.length == 0 || abi.decode(data, (bool))))) revert(RevertMsgExtractor.getRevertMsg(data));\n    }\n\n    /// @notice Transfers ETH to the recipient address\n    /// @dev Errors with the underlying revert message if transfer fails\n    /// @param to The destination of the transfer\n    /// @param value The value to be transferred\n    function safeTransferETH(address payable to, uint256 value) internal {\n        (bool success, bytes memory data) = to.call{value: value}(new bytes(0));\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(data));\n    }\n}"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastU256I128.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastU256I128 {\n    /// @dev Safe casting from uint256 to int256\n    function i128(uint256 x) internal pure returns(int128) {\n        require(x <= uint256(int256(type(int128).max)), \"Cast overflow\");\n        return int128(int256(x));\n    }\n}\n\n"
    },
    "contracts/vault/LadleStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \"@yield-protocol/vault-interfaces/ICauldron.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoin.sol\";\nimport \"@yield-protocol/yieldspace-interfaces/IPool.sol\";\nimport \"@yield-protocol/utils-v2/contracts/interfaces/IWETH9.sol\";\nimport \"./Router.sol\";\n\n/// @dev Ladle orchestrates contract calls throughout the Yield Protocol v2 into useful and efficient user oriented features.\ncontract LadleStorage {\n    event JoinAdded(bytes6 indexed assetId, address indexed join);\n    event PoolAdded(bytes6 indexed seriesId, address indexed pool);\n    event ModuleAdded(address indexed module, bool indexed set);\n    event IntegrationAdded(address indexed integration, bool indexed set);\n    event TokenAdded(address indexed token, bool indexed set);\n    event FeeSet(uint256 fee);\n\n    ICauldron public immutable cauldron;\n    Router public immutable router;\n    IWETH9 public immutable weth;\n    uint256 public borrowingFee;\n    bytes12 cachedVaultId;\n\n    mapping(bytes6 => IJoin) public joins; // Join contracts available to manage assets. The same Join can serve multiple assets (ETH-A, ETH-B, etc...)\n    mapping(bytes6 => IPool) public pools; // Pool contracts available to manage series. 12 bytes still free.\n    mapping(address => bool) public modules; // Trusted contracts to delegatecall anything on.\n    mapping(address => bool) public integrations; // Trusted contracts to call anything on.\n    mapping(address => bool) public tokens; // Trusted contracts to call `transfer` or `permit` on.\n\n    constructor(ICauldron cauldron_, IWETH9 weth_) {\n        cauldron = cauldron_;\n        router = new Router();\n        weth = weth_;\n    }\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/interfaces/IWETH9.sol": {
      "content": "// SPDX-License-Identifier: MIT\nimport \"../token/IERC20.sol\";\n\npragma solidity ^0.8.0;\n\n\ninterface IWETH9 is IERC20 {\n    event  Deposit(address indexed dst, uint wad);\n    event  Withdrawal(address indexed src, uint wad);\n\n    function deposit() external payable;\n    function withdraw(uint wad) external;\n}"
    },
    "contracts/vault/Router.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\nimport \"@yield-protocol/utils-v2/contracts/utils/RevertMsgExtractor.sol\";\nimport \"@yield-protocol/utils-v2/contracts/utils/IsContract.sol\";\n\n/// @dev Router forwards calls between two contracts, so that any permissions\n/// given to the original caller are stripped from the call.\n/// This is useful when implementing generic call routing functions on contracts\n/// that might have ERC20 approvals or AccessControl authorizations.\ncontract Router {\n    using IsContract for address;\n\n    address public immutable owner;\n\n    constructor() {\n        owner = msg.sender;\n    }\n\n    /// @dev Allow users to route calls to a pool, to be used with batch\n    function route(address target, bytes calldata data)\n        external\n        payable\n        returns (bytes memory result)\n    {\n        require(msg.sender == owner, \"Only owner\");\n        require(target.isContract(), \"Target is not a contract\");\n        bool success;\n        (success, result) = target.call(data);\n        if (!success) revert(RevertMsgExtractor.getRevertMsg(result));\n    }\n}\n"
    },
    "contracts/vault/Join.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"erc3156/contracts/interfaces/IERC3156FlashBorrower.sol\";\nimport \"erc3156/contracts/interfaces/IERC3156FlashLender.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoin.sol\";\nimport \"@yield-protocol/vault-interfaces/IJoinFactory.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/TransferHelper.sol\";\nimport \"@yield-protocol/utils-v2/contracts/math/WMul.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastU256U128.sol\";\n\ncontract Join is IJoin, IERC3156FlashLender, AccessControl {\n    using TransferHelper for IERC20;\n    using WMul for uint256;\n    using CastU256U128 for uint256;\n\n    event FlashFeeFactorSet(uint256 indexed fee);\n\n    bytes32 internal constant FLASH_LOAN_RETURN =\n        keccak256(\"ERC3156FlashBorrower.onFlashLoan\");\n    uint256 constant FLASH_LOANS_DISABLED = type(uint256).max;\n\n    address public immutable override asset;\n    uint256 public storedBalance;\n    uint256 public flashFeeFactor = FLASH_LOANS_DISABLED; // Fee on flash loans, as a percentage in fixed point with 18 decimals. Flash loans disabled by default.\n\n    constructor(address asset_) {\n        asset = asset_;\n    }\n\n    /// @dev Set the flash loan fee factor\n    function setFlashFeeFactor(uint256 flashFeeFactor_) external auth {\n        flashFeeFactor = flashFeeFactor_;\n        emit FlashFeeFactorSet(flashFeeFactor_);\n    }\n\n    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.\n    function join(address user, uint128 amount)\n        external\n        override\n        auth\n        returns (uint128)\n    {\n        return _join(user, amount);\n    }\n\n    /// @dev Take `amount` `asset` from `user` using `transferFrom`, minus any unaccounted `asset` in this contract.\n    function _join(address user, uint128 amount) internal returns (uint128) {\n        IERC20 token = IERC20(asset);\n        uint256 _storedBalance = storedBalance;\n        uint256 available = token.balanceOf(address(this)) - _storedBalance; // Fine to panic if this underflows\n        storedBalance = _storedBalance + amount;\n        unchecked {\n            if (available < amount)\n                token.safeTransferFrom(user, address(this), amount - available);\n        }\n        return amount;\n    }\n\n    /// @dev Transfer `amount` `asset` to `user`\n    function exit(address user, uint128 amount)\n        external\n        override\n        auth\n        returns (uint128)\n    {\n        return _exit(user, amount);\n    }\n\n    /// @dev Transfer `amount` `asset` to `user`\n    function _exit(address user, uint128 amount) internal returns (uint128) {\n        IERC20 token = IERC20(asset);\n        storedBalance -= amount;\n        token.safeTransfer(user, amount);\n        return amount;\n    }\n\n    /// @dev Retrieve any tokens other than the `asset`. Useful for airdropped tokens.\n    function retrieve(IERC20 token, address to) external auth {\n        require(address(token) != address(asset), \"Use exit for asset\");\n        token.safeTransfer(to, token.balanceOf(address(this)));\n    }\n\n    /**\n     * @dev From ERC-3156. The amount of currency available to be lended.\n     * @param token The loan currency. It must be a FYDai contract.\n     * @return The amount of `token` that can be borrowed.\n     */\n    function maxFlashLoan(address token)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        return token == asset ? storedBalance : 0;\n    }\n\n    /**\n     * @dev From ERC-3156. The fee to be charged for a given loan.\n     * @param token The loan currency. It must be the asset.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function flashFee(address token, uint256 amount)\n        external\n        view\n        override\n        returns (uint256)\n    {\n        require(token == asset, \"Unsupported currency\");\n        return _flashFee(amount);\n    }\n\n    /**\n     * @dev The fee to be charged for a given loan.\n     * @param amount The amount of tokens lent.\n     * @return The amount of `token` to be charged for the loan, on top of the returned principal.\n     */\n    function _flashFee(uint256 amount) internal view returns (uint256) {\n        return amount.wmul(flashFeeFactor);\n    }\n\n    /**\n     * @dev From ERC-3156. Loan `amount` `asset` to `receiver`, which needs to return them plus fee to this contract within the same transaction.\n     * If the principal + fee are transferred to this contract, they won't be pulled from the receiver.\n     * @param receiver The contract receiving the tokens, needs to implement the `onFlashLoan(address user, uint256 amount, uint256 fee, bytes calldata)` interface.\n     * @param token The loan currency. Must be a fyDai contract.\n     * @param amount The amount of tokens lent.\n     * @param data A data parameter to be passed on to the `receiver` for any custom use.\n     */\n    function flashLoan(\n        IERC3156FlashBorrower receiver,\n        address token,\n        uint256 amount,\n        bytes memory data\n    ) external override returns (bool) {\n        require(token == asset, \"Unsupported currency\");\n        uint128 _amount = amount.u128();\n        uint128 _fee = _flashFee(amount).u128();\n        _exit(address(receiver), _amount);\n\n        require(\n            receiver.onFlashLoan(msg.sender, token, _amount, _fee, data) ==\n                FLASH_LOAN_RETURN,\n            \"Non-compliant borrower\"\n        );\n\n        _join(address(receiver), _amount + _fee);\n        return true;\n    }\n}\n"
    },
    "contracts/vault/JoinFactory.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/vault-interfaces/IJoinFactory.sol\";\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"./Join.sol\";\n\n/// @dev The JoinFactory creates new join instances.\ncontract JoinFactory is IJoinFactory, AccessControl {\n    /// @dev Deploys a new join.\n    /// @param asset Address of the asset token.\n    /// @return join The join address.\n    function createJoin(address asset)\n        external\n        override\n        auth\n        returns (address)\n    {\n        Join join = new Join(asset);\n\n        join.grantRole(ROOT, msg.sender);\n        join.renounceRole(ROOT, address(this));\n\n        emit JoinCreated(asset, address(join));\n\n        return address(join);\n    }\n}\n"
    },
    "contracts/vault/compound/CTokenMultiOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20Metadata.sol\";\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"../constants/Constants.sol\";\nimport \"./CTokenInterface.sol\";\n\ncontract CTokenMultiOracle is IOracle, AccessControl, Constants {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SourceSet(\n        bytes6 indexed baseId,\n        bytes6 indexed quoteId,\n        CTokenInterface indexed cToken\n    );\n\n    struct Source {\n        CTokenInterface source;\n        uint8 baseDecimals;\n        uint8 quoteDecimals;\n        bool inverse;\n    }\n\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n\n    /// @dev Set or reset an oracle source and its inverse\n    function setSource(\n        bytes6 cTokenId,\n        bytes6 underlyingId,\n        CTokenInterface cToken\n    ) external auth {\n        IERC20Metadata underlying = IERC20Metadata(cToken.underlying());\n        uint8 underlyingDecimals = underlying.decimals();\n        uint8 cTokenDecimals = underlyingDecimals + 10; // https://compound.finance/docs/ctokens#exchange-rate\n        sources[cTokenId][underlyingId] = Source({\n            source: cToken,\n            baseDecimals: cTokenDecimals,\n            quoteDecimals: underlyingDecimals,\n            inverse: false\n        });\n        emit SourceSet(cTokenId, underlyingId, cToken);\n\n        sources[underlyingId][cTokenId] = Source({\n            source: cToken,\n            baseDecimals: underlyingDecimals, // We are reversing the base and the quote\n            quoteDecimals: cTokenDecimals,\n            inverse: true\n        });\n        emit SourceSet(underlyingId, cTokenId, cToken);\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     */\n    function peek(\n        bytes32 base,\n        bytes32 quote,\n        uint256 amountBase\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256 amountQuote, uint256 updateTime)\n    {\n        Source memory source = sources[base.b6()][quote.b6()];\n        require(\n            source.source != CTokenInterface(address(0)),\n            \"Source not found\"\n        );\n\n        uint256 price = source.source.exchangeRateStored();\n        require(price > 0, \"Compound price is zero\");\n\n        if (source.inverse == true) {\n            // ETH/USDC: 1 ETH (*10^18) * (1^6)/(286253688799857 ETH per USDC) = 3493404763 USDC wei\n            amountQuote =\n                (amountBase * (10**source.quoteDecimals)) /\n                uint256(price);\n        } else {\n            // USDC/ETH: 3000 USDC (*10^6) * 286253688799857 ETH per USDC / 10^6 = 858761066399571000 ETH wei\n            amountQuote =\n                (uint256(price) * amountBase) /\n                (10**source.baseDecimals);\n        }\n        updateTime = block.timestamp; // TODO: We should get the timestamp\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price. Updates the price before fetching it if possible.\n     */\n    function get(\n        bytes32 base,\n        bytes32 quote,\n        uint256 amountBase\n    )\n        external\n        virtual\n        override\n        returns (uint256 amountQuote, uint256 updateTime)\n    {\n        Source memory source = sources[base.b6()][quote.b6()];\n        require(\n            source.source != CTokenInterface(address(0)),\n            \"Source not found\"\n        );\n\n        uint256 price = source.source.exchangeRateCurrent();\n        require(price > 0, \"Compound price is zero\");\n\n        if (source.inverse == true) {\n            // USDC/cUSDC: 1 USDC (*10^6) * (1^16)/(x USDC per cUSDC) = y cUSDC wei\n            amountQuote =\n                (amountBase * (10**source.quoteDecimals)) /\n                uint256(price);\n        } else {\n            // cUSDC/USDC: 3000 cUSDC (*10^18) * x USDC per cUSDC / 10^16 = y USDC wei\n            amountQuote =\n                (amountBase * uint256(price)) /\n                (10**source.baseDecimals);\n        }\n        updateTime = block.timestamp; // TODO: We should get the timestamp\n    }\n}\n"
    },
    "@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol": {
      "content": "// SPDX-License-Identifier: BUSL-1.1\npragma solidity ^0.8.0;\n\n\nlibrary CastBytes32Bytes6 {\n    function b6(bytes32 x) internal pure returns (bytes6 y){\n        require (bytes32(y = bytes6(x)) == x, \"Cast overflow\");\n    }\n}\n"
    },
    "contracts/vault/compound/CTokenInterface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.5.16;\n\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20.sol\";\n\ninterface CTokenInterface {\n    /**\n     * @notice Accumulator of the total earned interest rate since the opening of the market\n     */\n    function borrowIndex() external view returns (uint256);\n\n    /**\n     * @notice Accrue interest then return the up-to-date exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateCurrent() external returns (uint256);\n\n    /**\n     * @notice Calculates the exchange rate from the underlying to the CToken\n     * @dev This function does not accrue interest before calculating the exchange rate\n     * @return Calculated exchange rate scaled by 1e18\n     */\n    function exchangeRateStored() external view returns (uint256);\n\n    /**\n     * @notice Underlying asset for this CToken\n     */\n    function underlying() external view returns (address);\n}\n"
    },
    "contracts/vault/compound/CompoundMultiOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\";\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"../constants/Constants.sol\";\nimport \"./CTokenInterface.sol\";\n\ncontract CompoundMultiOracle is IOracle, AccessControl, Constants {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SourceSet(\n        bytes6 indexed baseId,\n        bytes6 indexed kind,\n        address indexed source\n    );\n\n    mapping(bytes6 => mapping(bytes6 => address)) public sources;\n\n    /**\n     * @notice Set or reset a source\n     */\n    function setSource(\n        bytes6 base,\n        bytes6 kind,\n        address source\n    ) external auth {\n        sources[base][kind] = source;\n        emit SourceSet(base, kind, source);\n    }\n\n    /**\n     * @notice Retrieve the latest stored accumulator.\n     */\n    function peek(\n        bytes32 base,\n        bytes32 kind,\n        uint256\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256 accumulator, uint256 updateTime)\n    {\n        (accumulator, updateTime) = _peek(base.b6(), kind.b6());\n    }\n\n    /**\n     * @notice Retrieve the latest accumulator from source, updating it if necessary.\n     */\n    function get(\n        bytes32 base,\n        bytes32 kind,\n        uint256\n    )\n        external\n        virtual\n        override\n        returns (uint256 accumulator, uint256 updateTime)\n    {\n        (accumulator, updateTime) = _peek(base.b6(), kind.b6());\n    }\n\n    /**\n     * @notice Retrieve the value of the amount at the latest oracle price.\n     */\n    function _peek(bytes6 base, bytes6 kind)\n        private\n        view\n        returns (uint256 accumulator, uint256 updateTime)\n    {\n        address source = sources[base][kind];\n        require(source != address(0), \"Source not found\");\n\n        if (kind == RATE.b6())\n            accumulator = CTokenInterface(source).borrowIndex();\n        else if (kind == CHI.b6())\n            accumulator = CTokenInterface(source).exchangeRateStored();\n        else revert(\"Unknown oracle type\");\n\n        require(accumulator > 0, \"Compound accumulator is zero\");\n\n        updateTime = block.timestamp;\n    }\n}\n"
    },
    "contracts/vault/chainlink/ChainlinkUSDMultiOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20Metadata.sol\";\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"../constants/Constants.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\n/**\n * @title ChainlinkUSDMultiOracle\n * @notice Chainlink only uses USD or ETH as a quote in the aggregators, and we will use only USD\n */\ncontract ChainlinkUSDMultiOracle is IOracle, AccessControl, Constants {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SourceSet(\n        bytes6 indexed baseId,\n        IERC20Metadata base,\n        address indexed source\n    );\n\n    struct Source {\n        address source;\n        uint8 baseDecimals;\n    }\n\n    mapping(bytes6 => Source) public sources;\n\n    /// @dev Set or reset an oracle source and its inverse\n    function setSource(\n        bytes6 baseId,\n        IERC20Metadata base,\n        address source\n    ) external auth {\n        require(\n            AggregatorV3Interface(source).decimals() == 8,\n            \"Non-8-decimals USD source\"\n        );\n\n        sources[baseId] = Source({\n            source: source,\n            baseDecimals: base.decimals()\n        });\n        emit SourceSet(baseId, base, source);\n    }\n\n    /// @dev Convert amountBase base into quote at the latest oracle price.\n    function peek(\n        bytes32 baseId,\n        bytes32 quoteId,\n        uint256 amountBase\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256 amountQuote, uint256 updateTime)\n    {\n        if (baseId == quoteId) return (amountBase, block.timestamp);\n\n        (amountQuote, updateTime) = _peekThroughUSD(\n            baseId.b6(),\n            quoteId.b6(),\n            amountBase\n        );\n    }\n\n    /// @dev Convert amountBase base into quote at the latest oracle price, updating state if necessary. Same as `peek` for this oracle.\n    function get(\n        bytes32 baseId,\n        bytes32 quoteId,\n        uint256 amountBase\n    )\n        external\n        virtual\n        override\n        returns (uint256 amountQuote, uint256 updateTime)\n    {\n        if (baseId == quoteId) return (amountBase, block.timestamp);\n\n        (amountQuote, updateTime) = _peekThroughUSD(\n            baseId.b6(),\n            quoteId.b6(),\n            amountBase\n        );\n    }\n\n    /// @dev returns price for `baseId` in USD and base (not USD!) decimals\n    function _getPriceInUSD(bytes6 baseId)\n        private\n        view\n        returns (\n            uint256 uintPrice,\n            uint256 updateTime,\n            uint8 baseDecimals\n        )\n    {\n        int256 price;\n        uint80 roundId;\n        uint80 answeredInRound;\n        Source memory source = sources[baseId];\n        require(source.source != address(0), \"Source not found\");\n        (roundId, price, , updateTime, answeredInRound) = AggregatorV3Interface(\n            source.source\n        ).latestRoundData();\n        require(price > 0, \"Chainlink price <= 0\");\n        require(updateTime != 0, \"Incomplete round\");\n        require(answeredInRound >= roundId, \"Stale price\");\n\n        uintPrice = uint256(price);\n        baseDecimals = source.baseDecimals;\n    }\n\n    /// @dev Convert amountBase base into quote at the latest oracle price, using USD as an intermediate step.\n    function _peekThroughUSD(\n        bytes6 baseId,\n        bytes6 quoteId,\n        uint256 amountBase\n    ) private view returns (uint256 amountQuote, uint256 updateTime) {\n        (\n            uint256 basePrice,\n            uint256 updateTime1,\n            uint8 baseDecimals\n        ) = _getPriceInUSD(baseId);\n        (\n            uint256 quotePrice,\n            uint256 updateTime2,\n            uint8 quoteDecimals\n        ) = _getPriceInUSD(quoteId);\n\n        // decimals: baseDecimals * udcDecimals / usdDecimals\n        amountQuote = (amountBase * basePrice) / quotePrice;\n\n        // now need to convert baseDecimals to quoteDecimals\n        if (baseDecimals <= quoteDecimals) {\n            amountQuote *= (10**(quoteDecimals - baseDecimals));\n        } else {\n            amountQuote /= (10**(baseDecimals - quoteDecimals));\n        }\n\n        updateTime = (updateTime1 < updateTime2) ? updateTime1 : updateTime2;\n    }\n}\n"
    },
    "contracts/vault/chainlink/AggregatorV3Interface.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.6.0;\n\ninterface AggregatorV3Interface {\n\n  function decimals() external view returns (uint8);\n  function description() external view returns (string memory);\n  function version() external view returns (uint256);\n\n  // getRoundData and latestRoundData should both raise \"No data present\"\n  // if they do not have data to report, instead of returning unset values\n  // which could be misinterpreted as actual reported values.\n  function getRoundData(uint80 _roundId)\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n  function latestRoundData()\n    external\n    view\n    returns (\n      uint80 roundId,\n      int256 answer,\n      uint256 startedAt,\n      uint256 updatedAt,\n      uint80 answeredInRound\n    );\n\n}\n"
    },
    "contracts/vault/chainlink/ChainlinkMultiOracle.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.6;\n\nimport \"@yield-protocol/utils-v2/contracts/access/AccessControl.sol\";\nimport \"@yield-protocol/utils-v2/contracts/cast/CastBytes32Bytes6.sol\";\nimport \"@yield-protocol/utils-v2/contracts/token/IERC20Metadata.sol\";\nimport \"@yield-protocol/vault-interfaces/IOracle.sol\";\nimport \"../constants/Constants.sol\";\nimport \"./AggregatorV3Interface.sol\";\n\n/**\n * @title ChainlinkMultiOracle\n * @notice Chainlink only uses USD or ETH as a quote in the aggregators, and we will use only ETH\n */\ncontract ChainlinkMultiOracle is IOracle, AccessControl, Constants {\n    using CastBytes32Bytes6 for bytes32;\n\n    event SourceSet(\n        bytes6 indexed baseId,\n        IERC20Metadata base,\n        bytes6 indexed quoteId,\n        IERC20Metadata quote,\n        address indexed source\n    );\n\n    struct Source {\n        address source;\n        uint8 baseDecimals;\n        uint8 quoteDecimals;\n        bool inverse;\n    }\n\n    mapping(bytes6 => mapping(bytes6 => Source)) public sources;\n\n    /// @dev Set or reset an oracle source and its inverse\n    function setSource(\n        bytes6 baseId,\n        IERC20Metadata base,\n        bytes6 quoteId,\n        IERC20Metadata quote,\n        address source\n    ) external auth {\n        sources[baseId][quoteId] = Source({\n            source: source,\n            baseDecimals: base.decimals(),\n            quoteDecimals: quote.decimals(),\n            inverse: false\n        });\n        emit SourceSet(baseId, base, quoteId, quote, source);\n\n        if (baseId != quoteId) {\n            sources[quoteId][baseId] = Source({\n                source: source,\n                baseDecimals: quote.decimals(), // We are reversing the base and the quote\n                quoteDecimals: base.decimals(),\n                inverse: true\n            });\n            emit SourceSet(quoteId, quote, baseId, base, source);\n        }\n    }\n\n    /// @dev Convert amountBase base into quote at the latest oracle price.\n    function peek(\n        bytes32 baseId,\n        bytes32 quoteId,\n        uint256 amountBase\n    )\n        external\n        view\n        virtual\n        override\n        returns (uint256 amountQuote, uint256 updateTime)\n    {\n        if (baseId == quoteId) return (amountBase, block.timestamp);\n        if (baseId == ETH || quoteId == ETH)\n            (amountQuote, updateTime) = _peek(\n                baseId.b6(),\n                quoteId.b6(),\n                amountBase\n            );\n        else\n            (amountQuote, updateTime) = _peekThroughETH(\n                baseId.b6(),\n                quoteId.b6(),\n                amountBase\n            );\n    }\n\n    /// @dev Convert amountBase base into quote at the latest oracle price, updating state if necessary. Same as `peek` for this oracle.\n    function get(\n        bytes32 baseId,\n        bytes32 quoteId,\n        uint256 amountBase\n    )\n        external\n        virtual\n        override\n        returns (uint256 amountQuote, uint256 updateTime)\n    {\n        if (baseId == quoteId) return (amountBase, block.timestamp);\n        if (baseId == ETH || quoteId == ETH)\n            (amountQuote, updateTime) = _peek(\n                baseId.b6(),\n                quoteId.b6(),\n                amountBase\n            );\n        else\n            (amountQuote, updateTime) = _peekThroughETH(\n                baseId.b6(),\n                quoteId.b6(),\n                amountBase\n            );\n    }\n\n    /// @dev Convert amountBase base into quote at the latest oracle price.\n    function _peek(\n        bytes6 baseId,\n        bytes6 quoteId,\n        uint256 amountBase\n    ) private view returns (uint256 amountQuote, uint256 updateTime) {\n        int256 price;\n        uint80 roundId;\n        uint80 answeredInRound;\n        Source memory source = sources[baseId][quoteId];\n        require(source.source != address(0), \"Source not found\");\n        (roundId, price, , updateTime, answeredInRound) = AggregatorV3Interface(\n            source.source\n        ).latestRoundData();\n        require(price > 0, \"Chainlink price <= 0\");\n        require(updateTime != 0, \"Incomplete round\");\n        require(answeredInRound >= roundId, \"Stale price\");\n        if (source.inverse == true) {\n            // ETH/USDC: 1 ETH (*10^18) * (1^6)/(286253688799857 ETH per USDC) = 3493404763 USDC wei\n            amountQuote =\n                (amountBase * (10**source.quoteDecimals)) /\n                uint256(price);\n        } else {\n            // USDC/ETH: 3000 USDC (*10^6) * 286253688799857 ETH per USDC / 10^6 = 858761066399571000 ETH wei\n            amountQuote =\n                (amountBase * uint256(price)) /\n                (10**source.baseDecimals);\n        }\n    }\n\n    /// @dev Convert amountBase base into quote at the latest oracle price, using ETH as an intermediate step.\n    function _peekThroughETH(\n        bytes6 baseId,\n        bytes6 quoteId,\n        uint256 amountBase\n    ) private view returns (uint256 amountQuote, uint256 updateTime) {\n        (uint256 ethAmount, uint256 updateTime1) = _peek(\n            baseId,\n            ETH,\n            amountBase\n        );\n        (amountQuote, updateTime) = _peek(ETH, quoteId, ethAmount);\n        if (updateTime1 < updateTime) updateTime = updateTime1;\n    }\n}\n"
    }
  },
  "settings": {
    "outputSelection": {
      "*": {
        "*": [
          "storageLayout",
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "evm.gasEstimates"
        ],
        "": [
          "ast"
        ]
      }
    },
    "optimizer": {
      "enabled": true,
      "runs": 1
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}